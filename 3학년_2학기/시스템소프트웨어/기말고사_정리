- 1208
- 기말고사 정리

- 상위 설계 
  - 소프트웨어 설계 
    - 분석 단계
      - 사용자의 요구 사항을 토대로 '요구 분석 명세서 작성' 
      - 개념적이고 추상적, what 관점 

    - 설계 단계
      - 분석 단계에서 파악한 비기능적 요구 사항과 제약 사항 고려 
      - 운영체제, 미들웨어, 프레임워크 등의 플랫폼 결정, how 관점 

    - 설계 
      - 요구 분석 명세서를 기반으로 어떻게 구축할 것인가를 결정하는 것 
      - 설계를 평가할 수 있는 기준도 정량적으로 명시 

- 좋은 설계의 조건 
  - 요구 분석 명세서의 내용을 설계서에 모두 포함해야 한다. 
  - 유지보수가 용이하도록 추적이 가능해야 한다. 
  - 변화에 쉽게 적응할 수 있어야 한다. 
  - 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다. 
  - 설계서는 읽기 쉽고, 이해하기 쉽게 작성해야 한다. 

★ 설계의 종류 
  - 상위 설계 : 아키텍처 설계 -> 데이터 설계 -> 인터페이스 정의 -> 사용자 인터페이스 설계 
  - 하위 설계 : 모듈 설계 -> 자료구조 설계 -> 알고리즘 설계

  - 상위 설계 
    - 아키텍처 설계 : 시스템의 전체적인 구조 
    - 데이터 설계 : 시스템에 필요한 정보를 자료구조와 데이터베이스 설계에 반영 
    - 시스템 분할 : 전체 시스템을 여러 개의 서브시스템으로 나눈다. 
    - 인터페이스 정의 : 시스템의 구조와 서브 시스템들 사이의 인터페이스가 명확 정의 
    - UI 설계 : 사용자가 익숙하고 편리하게 사용할 수 있도록 사용자 인터페이스 설계 

  - 하위 설계   
    - 각 모듈의 실제적인 내부를 알고리즘 형태로 표현 
    - 인터페이스에 대한 설명, 자료구조, 변수 등에 대한 상세한 정보를 작성 

- 설계의 원리 
  - 분할과 정복, 추상화, 단계적 분해, 모듈화, 정보은닉

  - 분할과 정복 : 큰 문제를 소 단위로 나누고 소 단위의 작업을 하나씩 처리하여 전체 일을 끝내는 방법 
  - 추상화 : 특정한 목적과 관련된 필주 정보만 추출하여 강조, 본질적인 문제에 집중할 수 있도록 하는 작업 
    - 과정 추상화, 데이터 추상화, 제어 추상화
  - 단계적 분해 : '하향식 설계'에서 사용, 기능을 점점 작은 단위로 나누어 점차적으로 구체화하는 방법 
  - 모듈화 : 규모가 큰것을 여러 개로 나눈 조각, 소프트웨어 구조를 이루는 기본적인 단위 
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다. 
    - 유일한 이름을 가지고, 독립적으로 컴파일이 가능하다, 모듈에서 또 다른 모듈을 호출할 수 있다. 

- 시스템 품질 속성 
  - 가용성 : 시스템이 운용될 수 있는 확률로, 시스템이 장애 발생 없이 서비스를 제공할 수 있는 능력 
  - 변경 용이성 : 변경 요구 사항을 받았을 때 쉽게 변경할 수 있는 능력 ( 변경 용이성을 고려하여 아키텍처를 결정 ) 
  - 성능 : 사용자 요청과 같은 이벤트가 발생했을 때, 빠르고 적절하게 반응할 수 있는 능력 
  - 보안성 : 허용되지 않은 접근에 대응할 수 있는 능력 
  - 사용성 : 소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성 
  - 테스트 용이성 : 사용자가 요구하는 기능을 만족스럽게 잘 수행하고 있는지를 얼마나 쉽고 철저하게 테스트 할 수 있는지를 나타냄 

★ 아키텍처 구축 절차 
  - 요구사항 분석 -> 아키텍처 분석 -> 아키텍처 설계 -> 검증 및 승인 

- 아키텍처의 관점 
  - UML 4+1 관점 : 논리적 관점, 구현 관점, 배치 관점, 프로세스 관점, 유스케이스 관점 

- 아키텍처 모델 
  - 기능의 분할과 배치 : 데이터 중심형 모델, 클라이언트-서버 모델, 계층 모델, MVC 모델 
  - 제어 관계 : 데이터 흐름 모델 

  - 데이터 중심형 모델 
    - 장점 : 데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능 
    - 단점 : 병목 현상 발생 가능, 서브 시스템과 repository 사이의 강한 결합 

  - client-server 모델
    - 네트워크를 이용하는 분산 시스템 형태 
    - 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용 

  - 계층 모델 
    - 기능을 몇 개의 계층으로 나누어 배치 
    - 구성 : 하위 계층은 서버, 상위 계층은 클라이언트 역할 

  ★ MVC 모델 ( Model, View, Controller 모델 ) 
    - 중앙 데이터 구조 
    - 같은 모델의 서브 시스템에 대하여 여러 뷰 시스템을 필요로 하는 시스템에 적합 
    
    - Model 서브 시스템 
      - 뷰/제어 서브시스템과 독립되어 모든 데이터 상태와 로직을 처리 
      - 특정 입,출력 방식에 영향을 받지 않고 무언가의 호출에 응답만 함 

    - View 서브 시스템 
      - 사용자와 직업 대화가 이루어지는 부분으로 데이터를 사용자에게 보여주는 역할 

    - Controller 서브 시스템 
      - 뷰를 통한 사용자의 요청을 적절한 모델 쪽으로 넘겨주고, 모델로부터 받은 응답을 다시 뷰를 통해 사용자에게 돌려주는 역할 

    - 장점 
      - 데이터를 화면에 표현하는 디자인과 로직을 분리함으로써 느슨한 결합 가능 
      - 구조 변경 요청 시 수정이 용이

    - 단점 
      - 기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가 
      - 속도가 중요한 프로젝트에 부적합 

- 하위 설계 
  - 모듈 설계 
    - 소프트웨어 개발에서 큰 문제를 작은 단위로 나누는 것 

  - 모듈 
    - 규모가 큰 것을 여러 개로 나눈 조각 
    - 소프트웨어 구조를 이루는 기본적인 단위   
    - 독립 프로그램도 하나의 모듈, 함수들도 하나의 모듈 

  - 모듈화의 특징 
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다.
    - 유일한 이름이 있어야 한다. 
    - 독립적으로 컴파일이 가능하다

  - 좋은 모듈 설계를 위한 원칙 
    - 모듈 건의 결합은 느슨하게 
    - 모듈 내 구성 요소들 간의 응집은 강하게 

  - 모듈화의 장점 
    - 복잡도가 감소한다. 
    - 변경하기 쉽고, 변경으로 인한 영향이 적다. 
    - 유지보수가 용이하다. 
    - 프로그램을 효율적으로 관리할 수 있다. 

  - 응집도 
    - 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도 
    - 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가 

  - 기능적 응집 
    - 함수적 응집 
    - 응집도가 가장 높은 경우이며 단일 기능의 요소로 하나의 모듈을 구성 

  - 순차적 응집 
    - 두 요소가 하나의 모듈을 구성한 경우 
    - 두 요소가 아주 밀접하므로 하나의 모듈로 묶을 만한 충분한 이유가 된다. 

  - 교환적 응집 
    - 정보적 응집 
    - 구성 요소들이 동일한 출력을 만들어낼 때도 교환적 응집 
    - 요소들 간의 순서는 중요하지 않다. 

  - 절차적 응집 
    - 어떤 구성 요소의 출력이 다음 구성 요소의 입력으로 사용되지 않고, 순서에 따라 수행만 된다는 것 

  - 시간적 응집 
    - 모듈 내 구성 요소들의 기능도 다르고, 한 요소의 출력을 입력으로 사용하는 것도 아니고, 요소들 간에 순서도 없다
    - 구성 요소들이 같은 시간대에 함께 실행된다는 이유로 하나의 모듈로 구성 

  - 논리적 응집 
    - 모듈 간 순서와 무관, 한 모듈의 풀력을 다른 모듈의 입력으로 사용하는 것도 아님 
    - 요소들 간에 공통점이 있거나 관련된 임무가 존재하거나 기능이 비슷하다는 이유로 하나의 모듈로 구성 

  - 우연적 응집 
    - 구성 요소들이 말 그대로 우연히 모여 구성 
    - 특별한 이유 없이, 크기가 커 몇 개의 모듈로 나누는 과정에서 우연히 같이 묶인 것 

  - 결합도
    - 모듈과 모듈 사이의 관계에서 관련 정도 
    - 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가 
    - 결합은 낮을 수록 좋은것

  - 데이터 결합 
    - 가장 좋은 모듈 간 결합 
    - 모듈들이 매개변수를 통해 데이터만 주고받음으로써 서로 간섭을 최소화 하는 관계
    - 모듈 간의 독립성 보장 
    - 하나의 모듈을 변경했을 때 다른 모듈에 미치는 영향이 아주 적음 

  - 바람직한 설계 
    - 모듈 간에는 꼭 필요한 데이터만 주고받도록 
    - 적은 인터페이스의 수를 통한 약한 결합 유지 
    - 매개변수로 제어 플래그보다 데이터를 사용 -> 유지보수 용이성 향상 
    - 낮은 결합도, 높은 응집도 

- 객체지향의 주요 개념과 특징 
  - 객체 
    - 실게계에 존재하거나 생각할 수 있는 것들 
    - 사전에 나와 있는 명사뿐 아니라 동사의 명사형까지도 모두 객체 

  - 클래스 
    - 공통되는 것들을 묶어서 대표적인 이름을 붙인 것 
    - 클래스가 개념적이라면, 객체는 구체적 

  - 구조체 
    - 서로 연관된 자료들만 모아 놓은 것 

  - 인스턴스 
    - 같은 클래스에 속하는 개개의 객체로, 하나의 클래스에서 생성된 객체
    - 클래스가 구체화되어, 클래스에서 정의된 속성과 성질을 가진 실제적인 객체로 표현된 것

  - 캡슐화 
    - 사용자들에게 해당 객체의 기능과 사용법만 제공하고 내부는 감추어 쉽게 사용할 수 있게 하는 개념 
    - 장점 
      - 데이터 보호, 추상화 용이, 사용법이 쉬움, 객체 간의 독립성 보장, 재사용성 증대 

  - 정보은닉 
    - 외부에서 객체의 내부를 들여다볼 수 없다는 개념 
    - 데이터나 값을 직접 참조하거나 접근할 수 없는 구조
    - 공개 인터페이스로 정의 된 메소드를 통해서만 접근 가능 
    - 역할 
      - 블랙박스 테스트 역할 
      - 자료구조 변경이 용이 
    - 장점 
      - 독립성 향상, 수정 용이, 이해도 증진, 확장성 증가 

  - 상속 
    - 상위 클래스의 모든 것을 하위 클래스가 물려 받아 내 것처럼 사용 
    - 장점 
      - 재사용성 증대, 확장 용이, 유지보수 용이, 추상화 가능 

  - 다형성 
    - 같은 이름의 메소드가 객체에 따라 다르게 동작하고, 서로 다른 구현을 제공 
    - 장점
      - 쉬운 변경, 확장 및 유지보수의 용이 

  - 메소드 오버로딩 
    - 한 클래스에 이름이 동일한 메소드가 중복 정의 되어 있는 경우 
    - 메소드 명이 같은데 구별하는 방법은 매개변수의 타입이나 개수로 구별 
    - 추상 클래스와 추상 메소드만 사용 

  - 메소드 오버라이딩 
    - 추상 클래스와 일반 클래스를 모두 사용 
    - 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 모두 무시하고 다시 재정의해서 사용 가능 

- 구현 
  - 표준 코딩 규칙의 장점 
    - 높은 가독성 : 프로그램을 읽기 쉬운 정도 
    - 간결하고 명확안 코딩 : 유지보수 향상 
    - 개발 시간의 단축 : 개발 시간 단축 

- 테스트 
  ★ 소프트웨어 테스트 정의  
    - 소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로, 개발 과정에서 생성되는 
      문서나 프로그램에 있는 오류를 여러 기술을 이용해 검증하는 작업 
    - 오류를 찾아내 정상적으로 실행될 수 있도록 하는 정도, 소프트웨어에 오류가 없음을 확인시켜주지는 못한다. 

  ★ 테스트 절차 
    - 테스트 계획 -> 테스트 케이스 설계 -> 테스트 실행 및 측정 -> 테스트 결과 분석 -> 오류 추적 및 수정 

    - 테스트 계획 
      - 어떤 항목을 정점적으로 테스트할 것인지 명확히 나타낸다. 

    - 테스트 케이스 설계 
      - 테스트할 프로젝트 문제의 성격을 파악하고 이 문제에 적합한 테스트 기법을 선정 

    - 테스트 실행 및 측정 
      - 테스트 계획서에 정의된 환경 맟 자원을 설정하여 테스트를 실행할 준비

    - 테스트 결과 분석
      - 얻어진 결과 값과 테스트 계획 단계에서 목표한 값을 비교하여 예정된 품질 목표가 달성되었는지를 비교 분석 

    - 오류 추적 및 수정 
      - 오류가 발생된 위치를 찾고, 오류 수정 우선순위를 결정하여 오류 제거 계획을 세운다. 

  - 테스트의 분류
    - 시각에 따른 테스트 -
        - 확인 테스트 
          - 각 단계에서 개발자의 시각으로 테스트 
          - 설계도 대로 만들었는지 테스트 
          - 이전 단계에서 생성된 산출물이 현 단계의 산출물에 정확이 반영되었는지 테스트 
          - 단점 
            - 사용자의 요구는 체크하지 않고, 오직 계산 과정이 맞는지만 검증 
    
        - 검증 테스트 
          - 사용자의 요구 사항대로 만들었는지를 테스트 
          - 소프트웨어가 사용자의 목적에 맞게 구현되었는지 확인 가능

    - 사용 목적에 따른 테스트 -
        - 운영 목적 적합성 테스트 
          - 소프트웨어가 시스템의 운영 목적에 적합한지를 테스트 
        
        - 수정 용이성 테스트 
          - 소프트웨어 수정이 얼마나 쉬운지 테스트 
  
        - 상호운용성 테스트 
          - 양립성, 일치성, 이식성, 재사용성 등을 체크 
  
        - 운영지원 용이성 테스트 
          - 문서화, 복원 가능성 등을 체크 

    - 프로그램 실행 여부에 따른 테스트 -
        - 정적 테스트 
          - 프로그램을 실행하지 않고 코드를 검토하며 오류를 찾는 방법 
  
        - 동적 테스트 
          - 프로그램을 실행하면서 오류를 찾는 방법 

  - 정적 테스트 
    - 프로그램 코드를 실행하지 않고 여러 참여자가 모여 소프트웨어 개발 중에 
      생성되는 모든 명세서나 코드를 검토해서 실패 보다는 결함을 찾아내는 방법 

    - 비공식 검토 : 산출물을 동료와 함께 책상에서 검사 
    - 공식 검토 : 동료와 전문가들이 수행, 결함을 찾기 위해 절차에 따라 적절히 계획되고 통제된다.
      - 공식 검토 수행 절차 : 계획 -> 착수 -> 개별 준비 -> 검토회의 수행 -> 재작업 및 수정 -> 완료 작업 또는 후속 처리 확인 

    - 개별 검토 : 체크리스트를 가지고 본인이 개발한 코드와 산출물 등을 검토 ( 본인이 검토 : 객관성이 떨어짐 )
    - 동료 검토 : 동료에게 검토를 의뢰하여 오류를 찾는 방법 ( 비공식 검토 ) 
 
    - 소프트웨어 검사 
      - 문제점을 찾는 데 초점을 두고, 검토회의 후 개발자가 해당 문제를 수정 
      - 소프트웨어 품질 보증 기법으로 유용 
      - 공식 검토에 속한다. 
        - 검사 절차 : 계획 -> 개괄 설명회 -> 검사 준비 -> 검사 회의 -> 수정 -> 후속 조치 

















- 1208
- 기말고사 정리

- 상위 설계 
  - 소프트웨어 설계 
    - 분석 단계
      - 사용자의 요구 사항을 토대로 '요구 분석 명세서 작성' 
      - 개념적이고 추상적, what 관점 

    - 설계 단계
      - 분석 단계에서 파악한 비기능적 요구 사항과 제약 사항 고려 
      - 운영체제, 미들웨어, 프레임워크 등의 플랫폼 결정, how 관점 

    - 설계 
      - 요구 분석 명세서를 기반으로 어떻게 구축할 것인가를 결정하는 것 
      - 설계를 평가할 수 있는 기준도 정량적으로 명시 

- 좋은 설계의 조건 
  - 요구 분석 명세서의 내용을 설계서에 모두 포함해야 한다. 
  - 유지보수가 용이하도록 추적이 가능해야 한다. 
  - 변화에 쉽게 적응할 수 있어야 한다. 
  - 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다. 
  - 설계서는 읽기 쉽고, 이해하기 쉽게 작성해야 한다. 

★ 설계의 종류 
  - 상위 설계 : 아키텍처 설계 -> 데이터 설계 -> 인터페이스 정의 -> 사용자 인터페이스 설계 
  - 하위 설계 : 모듈 설계 -> 자료구조 설계 -> 알고리즘 설계

  - 상위 설계 
    - 아키텍처 설계 : 시스템의 전체적인 구조 
    - 데이터 설계 : 시스템에 필요한 정보를 자료구조와 데이터베이스 설계에 반영 
    - 시스템 분할 : 전체 시스템을 여러 개의 서브시스템으로 나눈다. 
    - 인터페이스 정의 : 시스템의 구조와 서브 시스템들 사이의 인터페이스가 명확 정의 
    - UI 설계 : 사용자가 익숙하고 편리하게 사용할 수 있도록 사용자 인터페이스 설계 

  - 하위 설계   
    - 각 모듈의 실제적인 내부를 알고리즘 형태로 표현 
    - 인터페이스에 대한 설명, 자료구조, 변수 등에 대한 상세한 정보를 작성 

- 설계의 원리 
  - 분할과 정복, 추상화, 단계적 분해, 모듈화, 정보은닉

  - 분할과 정복 : 큰 문제를 소 단위로 나누고 소 단위의 작업을 하나씩 처리하여 전체 일을 끝내는 방법 
  - 추상화 : 특정한 목적과 관련된 필주 정보만 추출하여 강조, 본질적인 문제에 집중할 수 있도록 하는 작업 
    - 과정 추상화, 데이터 추상화, 제어 추상화
  - 단계적 분해 : '하향식 설계'에서 사용, 기능을 점점 작은 단위로 나누어 점차적으로 구체화하는 방법 
  - 모듈화 : 규모가 큰것을 여러 개로 나눈 조각, 소프트웨어 구조를 이루는 기본적인 단위 
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다. 
    - 유일한 이름을 가지고, 독립적으로 컴파일이 가능하다, 모듈에서 또 다른 모듈을 호출할 수 있다. 

- 시스템 품질 속성 
  - 가용성 : 시스템이 운용될 수 있는 확률로, 시스템이 장애 발생 없이 서비스를 제공할 수 있는 능력 
  - 변경 용이성 : 변경 요구 사항을 받았을 때 쉽게 변경할 수 있는 능력 ( 변경 용이성을 고려하여 아키텍처를 결정 ) 
  - 성능 : 사용자 요청과 같은 이벤트가 발생했을 때, 빠르고 적절하게 반응할 수 있는 능력 
  - 보안성 : 허용되지 않은 접근에 대응할 수 있는 능력 
  - 사용성 : 소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성 
  - 테스트 용이성 : 사용자가 요구하는 기능을 만족스럽게 잘 수행하고 있는지를 얼마나 쉽고 철저하게 테스트 할 수 있는지를 나타냄 

★ 아키텍처 구축 절차 
  - 요구사항 분석 -> 아키텍처 분석 -> 아키텍처 설계 -> 검증 및 승인 

- 아키텍처의 관점 
  - UML 4+1 관점 : 논리적 관점, 구현 관점, 배치 관점, 프로세스 관점, 유스케이스 관점 

- 아키텍처 모델 
  - 기능의 분할과 배치 : 데이터 중심형 모델, 클라이언트-서버 모델, 계층 모델, MVC 모델 
  - 제어 관계 : 데이터 흐름 모델 

  - 데이터 중심형 모델 
    - 장점 : 데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능 
    - 단점 : 병목 현상 발생 가능, 서브 시스템과 repository 사이의 강한 결합 

  - client-server 모델
    - 네트워크를 이용하는 분산 시스템 형태 
    - 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용 

  - 계층 모델 
    - 기능을 몇 개의 계층으로 나누어 배치 
    - 구성 : 하위 계층은 서버, 상위 계층은 클라이언트 역할 

  ★ MVC 모델 ( Model, View, Controller 모델 ) 
    - 중앙 데이터 구조 
    - 같은 모델의 서브 시스템에 대하여 여러 뷰 시스템을 필요로 하는 시스템에 적합 
    
    - Model 서브 시스템 
      - 뷰/제어 서브시스템과 독립되어 모든 데이터 상태와 로직을 처리 
      - 특정 입,출력 방식에 영향을 받지 않고 무언가의 호출에 응답만 함 

    - View 서브 시스템 
      - 사용자와 직업 대화가 이루어지는 부분으로 데이터를 사용자에게 보여주는 역할 

    - Controller 서브 시스템 
      - 뷰를 통한 사용자의 요청을 적절한 모델 쪽으로 넘겨주고, 모델로부터 받은 응답을 다시 뷰를 통해 사용자에게 돌려주는 역할 

    - 장점 
      - 데이터를 화면에 표현하는 디자인과 로직을 분리함으로써 느슨한 결합 가능 
      - 구조 변경 요청 시 수정이 용이

    - 단점 
      - 기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가 
      - 속도가 중요한 프로젝트에 부적합 

- 하위 설계 
  - 모듈 설계 
    - 소프트웨어 개발에서 큰 문제를 작은 단위로 나누는 것 

  - 모듈 
    - 규모가 큰 것을 여러 개로 나눈 조각 
    - 소프트웨어 구조를 이루는 기본적인 단위   
    - 독립 프로그램도 하나의 모듈, 함수들도 하나의 모듈 

  - 모듈화의 특징 
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다.
    - 유일한 이름이 있어야 한다. 
    - 독립적으로 컴파일이 가능하다

  - 좋은 모듈 설계를 위한 원칙 
    - 모듈 건의 결합은 느슨하게 
    - 모듈 내 구성 요소들 간의 응집은 강하게 

  - 모듈화의 장점 
    - 복잡도가 감소한다. 
    - 변경하기 쉽고, 변경으로 인한 영향이 적다. 
    - 유지보수가 용이하다. 
    - 프로그램을 효율적으로 관리할 수 있다. 

  - 응집도 
    - 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도 
    - 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가 

  - 기능적 응집 
    - 함수적 응집 
    - 응집도가 가장 높은 경우이며 단일 기능의 요소로 하나의 모듈을 구성 

  - 순차적 응집 
    - 두 요소가 하나의 모듈을 구성한 경우 
    - 두 요소가 아주 밀접하므로 하나의 모듈로 묶을 만한 충분한 이유가 된다. 

  - 교환적 응집 
    - 정보적 응집 
    - 구성 요소들이 동일한 출력을 만들어낼 때도 교환적 응집 
    - 요소들 간의 순서는 중요하지 않다. 

  - 절차적 응집 
    - 어떤 구성 요소의 출력이 다음 구성 요소의 입력으로 사용되지 않고, 순서에 따라 수행만 된다는 것 

  - 시간적 응집 
    - 모듈 내 구성 요소들의 기능도 다르고, 한 요소의 출력을 입력으로 사용하는 것도 아니고, 요소들 간에 순서도 없다
    - 구성 요소들이 같은 시간대에 함께 실행된다는 이유로 하나의 모듈로 구성 

  - 논리적 응집 
    - 모듈 간 순서와 무관, 한 모듈의 풀력을 다른 모듈의 입력으로 사용하는 것도 아님 
    - 요소들 간에 공통점이 있거나 관련된 임무가 존재하거나 기능이 비슷하다는 이유로 하나의 모듈로 구성 

  - 우연적 응집 
    - 구성 요소들이 말 그대로 우연히 모여 구성 
    - 특별한 이유 없이, 크기가 커 몇 개의 모듈로 나누는 과정에서 우연히 같이 묶인 것 

  - 결합도
    - 모듈과 모듈 사이의 관계에서 관련 정도 
    - 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가 
    - 결합은 낮을 수록 좋은것

  - 데이터 결합 
    - 가장 좋은 모듈 간 결합 
    - 모듈들이 매개변수를 통해 데이터만 주고받음으로써 서로 간섭을 최소화 하는 관계
    - 모듈 간의 독립성 보장 
    - 하나의 모듈을 변경했을 때 다른 모듈에 미치는 영향이 아주 적음 

  - 바람직한 설계 
    - 모듈 간에는 꼭 필요한 데이터만 주고받도록 
    - 적은 인터페이스의 수를 통한 약한 결합 유지 
    - 매개변수로 제어 플래그보다 데이터를 사용 -> 유지보수 용이성 향상 
    - 낮은 결합도, 높은 응집도 

- 객체지향의 주요 개념과 특징 
  - 객체 
    - 실게계에 존재하거나 생각할 수 있는 것들 
    - 사전에 나와 있는 명사뿐 아니라 동사의 명사형까지도 모두 객체 

  - 클래스 
    - 공통되는 것들을 묶어서 대표적인 이름을 붙인 것 
    - 클래스가 개념적이라면, 객체는 구체적 

  - 구조체 
    - 서로 연관된 자료들만 모아 놓은 것 

  - 인스턴스 
    - 같은 클래스에 속하는 개개의 객체로, 하나의 클래스에서 생성된 객체
    - 클래스가 구체화되어, 클래스에서 정의된 속성과 성질을 가진 실제적인 객체로 표현된 것

  - 캡슐화 
    - 사용자들에게 해당 객체의 기능과 사용법만 제공하고 내부는 감추어 쉽게 사용할 수 있게 하는 개념 
    - 장점 
      - 데이터 보호, 추상화 용이, 사용법이 쉬움, 객체 간의 독립성 보장, 재사용성 증대 

  - 정보은닉 
    - 외부에서 객체의 내부를 들여다볼 수 없다는 개념 
    - 데이터나 값을 직접 참조하거나 접근할 수 없는 구조
    - 공개 인터페이스로 정의 된 메소드를 통해서만 접근 가능 
    - 역할 
      - 블랙박스 테스트 역할 
      - 자료구조 변경이 용이 
    - 장점 
      - 독립성 향상, 수정 용이, 이해도 증진, 확장성 증가 

  - 상속 
    - 상위 클래스의 모든 것을 하위 클래스가 물려 받아 내 것처럼 사용 
    - 장점 
      - 재사용성 증대, 확장 용이, 유지보수 용이, 추상화 가능 

  - 다형성 
    - 같은 이름의 메소드가 객체에 따라 다르게 동작하고, 서로 다른 구현을 제공 
    - 장점
      - 쉬운 변경, 확장 및 유지보수의 용이 

  - 메소드 오버로딩 
    - 한 클래스에 이름이 동일한 메소드가 중복 정의 되어 있는 경우 
    - 메소드 명이 같은데 구별하는 방법은 매개변수의 타입이나 개수로 구별 
    - 추상 클래스와 추상 메소드만 사용 

  - 메소드 오버라이딩 
    - 추상 클래스와 일반 클래스를 모두 사용 
    - 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 모두 무시하고 다시 재정의해서 사용 가능 

- 구현 
  - 표준 코딩 규칙의 장점 
    - 높은 가독성 : 프로그램을 읽기 쉬운 정도 
    - 간결하고 명확안 코딩 : 유지보수 향상 
    - 개발 시간의 단축 : 개발 시간 단축 

- 테스트 
  ★ 소프트웨어 테스트 정의  
    - 소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로, 개발 과정에서 생성되는 
      문서나 프로그램에 있는 오류를 여러 기술을 이용해 검증하는 작업 
    - 오류를 찾아내 정상적으로 실행될 수 있도록 하는 정도, 소프트웨어에 오류가 없음을 확인시켜주지는 못한다. 

  ★ 테스트 절차 
    - 테스트 계획 -> 테스트 케이스 설계 -> 테스트 실행 및 측정 -> 테스트 결과 분석 -> 오류 추적 및 수정 

    - 테스트 계획 
      - 어떤 항목을 정점적으로 테스트할 것인지 명확히 나타낸다. 

    - 테스트 케이스 설계 
      - 테스트할 프로젝트 문제의 성격을 파악하고 이 문제에 적합한 테스트 기법을 선정 

    - 테스트 실행 및 측정 
      - 테스트 계획서에 정의된 환경 맟 자원을 설정하여 테스트를 실행할 준비

    - 테스트 결과 분석
      - 얻어진 결과 값과 테스트 계획 단계에서 목표한 값을 비교하여 예정된 품질 목표가 달성되었는지를 비교 분석 

    - 오류 추적 및 수정 
      - 오류가 발생된 위치를 찾고, 오류 수정 우선순위를 결정하여 오류 제거 계획을 세운다. 

  - 테스트의 분류
    - 시각에 따른 테스트 -
        - 확인 테스트 
          - 각 단계에서 개발자의 시각으로 테스트 
          - 설계도 대로 만들었는지 테스트 
          - 이전 단계에서 생성된 산출물이 현 단계의 산출물에 정확이 반영되었는지 테스트 
          - 단점 
            - 사용자의 요구는 체크하지 않고, 오직 계산 과정이 맞는지만 검증 
    
        - 검증 테스트 
          - 사용자의 요구 사항대로 만들었는지를 테스트 
          - 소프트웨어가 사용자의 목적에 맞게 구현되었는지 확인 가능

    - 사용 목적에 따른 테스트 -
        - 운영 목적 적합성 테스트 
          - 소프트웨어가 시스템의 운영 목적에 적합한지를 테스트 
        
        - 수정 용이성 테스트 
          - 소프트웨어 수정이 얼마나 쉬운지 테스트 
  
        - 상호운용성 테스트 
          - 양립성, 일치성, 이식성, 재사용성 등을 체크 
  
        - 운영지원 용이성 테스트 
          - 문서화, 복원 가능성 등을 체크 

    - 프로그램 실행 여부에 따른 테스트 -
        - 정적 테스트 
          - 프로그램을 실행하지 않고 코드를 검토하며 오류를 찾는 방법 
  
        - 동적 테스트 
          - 프로그램을 실행하면서 오류를 찾는 방법 

  ★ 정적 테스트 
    - 프로그램 코드를 실행하지 않고 여러 참여자가 모여 소프트웨어 개발 중에 
      생성되는 모든 명세서나 코드를 검토해서 실패 보다는 결함을 찾아내는 방법 

    - 비공식 검토 : 산출물을 동료와 함께 책상에서 검사 
    - 공식 검토 : 동료와 전문가들이 수행, 결함을 찾기 위해 절차에 따라 적절히 계획되고 통제된다.
      - 공식 검토 수행 절차 : 계획 -> 착수 -> 개별 준비 -> 검토회의 수행 -> 재작업 및 수정 -> 완료 작업 또는 후속 처리 확인 

    - 개별 검토 : 체크리스트를 가지고 본인이 개발한 코드와 산출물 등을 검토 ( 본인이 검토 : 객관성이 떨어짐 )
    - 동료 검토 : 동료에게 검토를 의뢰하여 오류를 찾는 방법 ( 비공식 검토 ) 
 
    - 소프트웨어 검사 
      - 문제점을 찾는 데 초점을 두고, 검토회의 후 개발자가 해당 문제를 수정 
      - 소프트웨어 품질 보증 기법으로 유용 
      - 공식 검토에 속한다. 
        - 검사 절차 : 계획 -> 개괄 설명회 -> 검사 준비 -> 검사 회의 -> 수정 -> 후속 조치 

  ★ 동적 테스트 
    ★ 명세 기반 테스트 ( 블랙박스 테스트 )  
      ★ 입력 값에 대한 예상출력 값을 정해놓고 그대로 결과가 나오는지를 체크 
      - 요구분석명세서나 설계 사양서에서 테스트 케이스를 추출하여 테스트 
      - 기능을 어떻게 수행하는가 보다는 사용자가 원하는 기능을 수행하는가 테스트 

    - 동적 테스트 
      - 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는다. 

    - 신택스 기법 
      - 문법에 기반을 둔 테스트 
      - 문법을 정해놓고 적합/부적합 입력 값에 따른 예상 결과가 제대로 나오는지 테스트 

    - 동등 분할 기법 
      - 각 영역에 해당하는 입력 값을 넣고 예상되는 출력 값이 나오는지 실제 값과 비교 
      - 예상 결과 값을 미리 정해놓는다. 그것과 실제 결과가 예상 값과 같은지를 확인 

    - 경계 값 분석 기법 
      - 경계에 있는 값을 테스트 데이터로 생성하여 테스트 하는 방법 

    - 구현 기반 테스트 
      - 코드 기반 테스트 
        - 원시코드를 확인하고 수정하는 테스트 기법 

      - 화이트 박스 테스트 
        - 명세서나 원시 코드를 분석하여 선정된 기준을 만족하는 입력 데이터를 만든다. 
        - 프로그램 실행 -> 실행 결과가 예상된 결과와 같은지 비교 
        - 문장 검증, 분기 검증, 조건 검증, 다중 조건 검증, 기본 경로 테스트 의 방법이 있다. 

        - 문장 검증 기준 
          - 프로그램 내의 모든문장이 최소한 한 번은 실행될 수 있는 테스트 데이터를 갖는 테스트 케이스를 선정 
          - 모든 로직이 한번씩 실행될 수 있는 테스트를 하는 것 

        - 분기 검증 기준 
          - 조건문에 대해 T,F가 최소한 한 번은 실행되는 입력 데이터를 테스트 케이스로 사용 
          - 분기 시점 또는 합류 위치에서 조건과 관련된 오류를 발견할 가능성이 높다. 

        - 기본 경로 테스트 
          - 원시 코드의 독립적인 경로가 최소한 한 번은 실행되는 테스트 케이스를 찾아 테스트 
          - 원시코드의 독립적인 경로를 모두 수행하는 것 
          - 수행 절차 : 코드 -> 순서도 작성 -> 흐름 그래프 작성 -> 순환 복잡도 계산 -> 독립적인 경로 정의 -> 테스트 케이스 작성 -> 테스트 
            - 순서도 작성, 흐름 그래프 작성, 순환 복잡도 계산, 독립적 경로 정의, 테스트 케이스 작성

  - 소프트웨어 개발 단계에 따른 테스트 
    - V모델 
      - 요구분석 -> 아키텍처 설계 -> 모듈 설계 -> 구현 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트 

      - 단위 테스트 ( 모듈 테스트 ) 
        - 프로그램의 기본 단위인 모듈을 테스트 
        - 명세서의 내용대로 정확히 구현되었는지를 테스트 

      ★ 통합 테스트 
        - 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생할 수 있는 오류를 찾는 테스트 
        - 한꺼번에 하는 방법 : big-bang 테스트 
        - 점진적으로 하는 방법 : 하향식 기법, 상향식 기법

        ★ 하향식 기법
          - 모듈의 계층 구조에서 맨 상위의 모듈부터 시작하여 점차 하위 모듈 방향으로 통합 
          - 넓이 우선 방식 ( BFS ) : 같은 행에서는 옆으로 가며 통합 ( 가장 위에서 부터 확인하며 아래 노드로 가면 왼쪽 부터 오른쪽으로 검사 )
          - 깊이 우선 방식 ( DFS ) : 같은 행에서는 아래로 가며 통합 
          - 장점 : 프로그램 전체에 영향을 줄 수 있는 오류를 일찍 발견하기 쉽다. 
          - 단점 : 하위 모듈이 임시로 만든 스텁들로 대체되어 결과가 완전하지 않을 수도 있다. 

        ★ 상향식 기법 
          - 가장 말단에 있는 최하위 모듈부터 테스트 
          - 상위 모듈의 역할을 하는 테스트 드라이버가 필요 
          - 장점 : 최하위 모듈들을 개별적으로 병행하여 테스트, 정밀한 계산이나 데이터 처리가 요구되는 시스템 같은 경우에 유용
          - 단점 : 상위 모듈에 오류가 발견되면 그 모듈과 관련된 하위의 모듈을 다시 테스트해야 함 

      - 시스템 테스트 
        - 시스템 전체가 정상적으로 작동하는지를 체크 
        - 모듈이 모두 통합된 후 사용자의 요구 사항들을 만족하는지 테스트 
        - 주로 부하를 주는 상황레서 수행하고, 비기능적 테스트를 중심으로 수행 

      - 인수 테스트 
        - 시스템이 예상대로 동작하는지 확인하고, 요구사항에 맞는지 확신하기 위해 하는 테스트 
        - 시스템을 인수하기 전 요구 분석 명세서에 명시된 대로 모두 충족시키는지를 사용자가 테스트 
        - 알파 테스트 : 내부 필드 테스트 ( 베타 테스트 개발자 환경에서 사용 ) 
        - 베타 테스트 : 알파 테스트 후 시장 출시 전 시작의 피드백을 얻기 위한 목적으로 테스트 ( 특정 사용자가 미리 사용 -> 오류 발견 -> 개발자에게 알려줌 )

      - 회귀 테스트 
        - 확정 테스트 : 원시 코드의 결함을 수정한 후 제대로 수정되었는지 확인하는 테스트 
        - 회귀 테스트 : 한 모듈의 수정이 다른 부분에 영향을 끼칠 수도 있다고 생각하여 수정된 모듈 뿐 아니라 관련된 모듈까지 문제가 없는지 테스트 
        - 점진적 회귀 테스트 : 사용 중에 일부 기능을 추가하여 새로운 버전을 만들고, 이 새 버전을 다시 테스트 

- 품질 
  - 물건이 얼마나 좋은지, 나쁜지를 나타내는 정도 
  
  - 하드웨어 품질 
    - 사용자의 요구사항을 규격서에 서술하고, 이 규격서대로 만들면 큰 문제가 없다. 
    - 만든 제품이 규격서대로 작동하는지 테스트 하는 것도 비교적 용이 

  - 소프트웨어 품질 정의 
    - 사용자의 요구와 부합되는 정도 

  - 관점에 따른 품질 
    - 프로젝트 관리자 관점의 좋은 소프트웨어 
      - 추가 부담이 발생하지 않는 소프트웨어 

    - 개발자 관점의 좋은 소프트웨어 
      - 개발하기 쉽고 사용 중 내용 추가 및 코드 수정이 쉽고 편리하게 변경 가능한 소프트웨어 

    - 유지보수자 관점의 좋은 소프트웨어 
      - 작성된 코드가 코딩 규칙 및 표준을 따르고 주석문이 많이 포함된 소프트웨어 

  - 품질 좋은 소프트웨어가 되려면 
    - 처음부터 품질을 고려한 계획을 세운다. 
    - 품질 요구 사항에 대한 명세서가 작성되어야 한다. 
    - 단계별로 생산되는 산출물도 검사 항목에 따라 철저히 점검해야 한다. 

  ★ 품질 목표 
    - 정확성 : 사용자가 요구하는 기능을 충족시키는 정도, 요구 분석 명세서와 일치하는 정도 
    - 신뢰성 : 사용자가 요구한 기능을 정확하고 일관되게 원하는 정밀도로 수행할 수 있는 정도 
    - 효율성 : 사용자가 요구한 기능을 수행하는 데, 최소의 시간과 기억 용량을 사용하여 요구되는 기능을 수행할 수 있는 정도 
    - 무결성 : 허가 받지 않은 사용자가 데이터 접근을 통해 변경을 시도했을 때 보호할 수 있는 정도 
    - 사용성 : 소프트웨어를 사용하는 데 있어서 혼란스러워하거나 사용하는 순간에 고민하지 않도록 편리한 기능을 제공하는 정도 
    - 유지보수 용이성 : 프로그램 내에 존재하는 오류를 찾아 수정하고 패치할 때 쉽게 변경할 수 있는 정도 
    - 테스트 용이성 : 쉽고 철저하게 테스트 할 수 있는 정도 
    - 유연성 : 운영 환경의 변화에 따라 새로운 기능을 추가하거나 다른 환경에 적용할 수 있게 운용되는 프로그램을 쉽게 수정할 수 있는 정도
    - 이식성 : 다른 하드웨어 환경에서도 운용 가능하도록 쉽게 수정하여 이식할 수 있는 정도 
    - 재사용성 : 시스템의 일부나 전체를 다른 애플리케이션에서도 쉽게 사용할 수 있는 정도 
    - 상호운용성 : 한 소프트웨어를 다른 소프트웨어와 쉽게 연계하거나 결합하여 정보를 교환할 수 있는 정도 

  - ISO 9000
    - 국제 표준화 기구 ISO가 정한 품질 관리와 품질 보증을 위한 모델 
    - 해당 제품이나 서비스 설계에서부터 생산 시설, 시험 등 전반에 걸쳐 규격준수 여부를 확인해 인증 
  
  - ISO 12207
    - 소프트웨어 개발 생명주기 프로세스인 소프트웨어 생성부터 폐기까지의 프로세스에 해당

  - 표준 프로세스의 필요성 
    - 소프트웨어 개발에서 레시피, 하나의 메뉴얼, 내비게이션과 같은 역할 
    - 생산성을 높인다. 

  - CMMI 5단계 
    - 초기 단계 : 예측/통제 불가능 
    - 관리 단계 : 기본적인 프로젝트 관리 체계 수립 
    - 정의 단계 : 조직 차원의 표준 프로세스를 통한 프로젝트 지원 
    - 정량적 관리 단계 : 정량적으로 프로세스가 측정/통제 됨 
    - 최적화 단계 : 프로세스 개선 활동 

  - 품질 관리 
    - 개발의 각 단계에서 일어나는 모든 활동과 활동 중에 생성되는 여러 산출물을 통제하고 보증하여 품질을 관리하기 위한 활동 

  - 품질 통제 
    - 품질 절차와 표준을 개발자들이 준수하도록 프로세스를 정의하고 규정을 만드는 것 

  - 품질 보증 정의 
    - 소프트웨어의 결함을 줄여 품질 좋은 소프트웨어를 만들기 위해, 사용자가 요구하는 품질 수준을 파악하고
      이를 어떻게 달성할 수 있는지를 정의하는 개발 단계 전역에 걸친 체계적인 작업 

- 프로젝트 관리 
  - 프로젝트 
    - 유일한 제품이나 서비스를 만들기 위해 일정한 기간을 정해놓고 수행하는 작업 

  ★ 프로젝트 특징 
    - 한시성 : 일의 시작과 끝이 명확히 정해져 있다. 
    - 유일성 : 기간이 종료되어 만들어 내는 인도물은 유일하다 
    - 참여자의 일시성 : 참여 인력은 프로젝트 시작과 동시에 참여하고, 종료되면 해체된다.
    - 한정성 : 프로젝트가 종료되면 사용된 자원은 원래의 위치로 돌아가던가 없앤다. 

  - 프로젝트 프로세스 그룹 관계도 ( 5가지 프로세스 그룹 ) 
    - 시작 -> 기획 -> 실행 -> 통제 -> 종료 

    - 시작 : 범위 관리 착수 및 프로젝트 또는 프로젝트를 구성하는 단계 정의 및 승인 
    - 기획 : 프로젝트 목표 설정 및 목표 달성을 위한 활동 계획과 예산, 인력, 자원 등의 계획 수립 
    - 실행 : 핵심 프로세스는 프로젝트 계획으로 계획을 세운대로 실제 프로젝트 수행 
    - 통제 : 계획 대비 목표의 진척 상황을 주기적으로 감시하고 성과를 측정
    - 종료 : 진행 중인 모든 항목들을 마무리하고 계약 종료 

  - 프로젝트 관리의 9가지 관점 
    - 통합 관리 
    - 범위 관리 
    - 일정 관리 
    - 비용 관리 
    - 품질 관리 
    - 인적 자원 관리 
    - 의사소통 관리 
    - 위험 관리 
    - 조달 관리 
  
  - 형상 관리 
    - 변경의 요인  
      - 업무 환경의 변화 
        - 새로운 기능의 추가와 같이 고객 요구의 변경 
        - 시장 여건의 변경 
        - 예산과 일정 계획 등에서의 변경 

      - 기술 환경의 변화 
        - 하드웨어의 사양 및 운영체제의 변경 

  - 버전 관리의 필요성 
    - 파일의 이력이나 차이점을 관리해 애플리케이션의 버전과 각 원시 파일이나 문서를 유용하게 활용하기 위함 

  - 형상 관리 
    - 형상 항목 
      - 수만에서 수십만 개의 부품으로 이루어져 있는 자동차나 비행기의 작은 단위의 부품들 

    ★ 형상 관리 
      - 특정 항목의 변화에 대해 관리하면서 시스템의 통합과 일치를 보장하는 것 

      - 형상 관리 효과 
        - 프로젝트의 적절한 통제 -> 체계적이고 효율적 관리 가능 
        - 가시성과 추적성 보장함 -> 소프트웨어의 생상성과 품질 향상 가능 

      - 형상 관리 수행 절차 
        - 형상 식별 
          - 형상 관리의 가장 밑바탕이 되는 활동 
          - 프로젝트 계획 시 형상 관리 계획을 근거로 형상 관리의 대상이 무엇인지 식별하는 과정 

        - 형상 통제 
          - 형상 목록의 변경 요구를 검토 및 승인하여 현재의 소프트웨어 기준선에 반영될 수 있도록 통제하는 일련의 과정 

        - 형상 상태 보고 
          - 베이스라인으로 설정된 형상 항목 구조와 변경 상태 기록 

        - 형상 감사 
          - 형상 관리 계획서대로 형상 관리가 진행되고 있는지, 형상 항목의 변경이 요구사항에 맞도록 제대로 이뤄졌는지를 살핌 
          - 단계별 베이스라인의 적정성과 무결성을 평가하고 승인 

    - 소프트웨어 형상 관리 
      - 개발 중 발생하는 모든 산출물들이 변경됨으로써 점차 변해가는 소프트웨어 형상을 체계적으로 관리하고 유지하는 기법 
      - 소프트웨어 개발 생명주기 전반에 걸쳐 생성되는 모든 산출물의 종합 및 변경 과정을 체계적으로 관리하고 유지하는 일련의 개발 관리 활동 

  - 유지보수
    - 수정 유지보수 
      - 개발된 소프트웨어를 사용자가 인도받은 후 사용하면서 발견되는 오류를 잡는 것 
      - 개발 과정에서 미처 바로잡지 못한 오류를 유지보수 단계에서 해결하는 것 
        
    - 적응 유지보수 
      - 개발된 소프트웨어가 처음 설치된 곳에서 문제없이 실행되다가 환경이 바뀌어도 이에 맞도록 수정,보완해주는 것 

    - 기능 보강 유지보수
      - 변경이 필요할 때 하게 된느 유지보수 

    - 예방 유지보수 
      - 미리 예상되거나 예측되는 오류를 찾아 수정하는 것 


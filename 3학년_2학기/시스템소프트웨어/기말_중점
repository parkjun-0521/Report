- 1212
- 분석 단계 
  - 사용자의 요구사항을 토대로 요구 분석 명세서 작성 

- 설계단계
  - 분석 단계에서 파악한 비기능적 요구 사항과 제약 사항 고려 

- 좋은 설계의 조건 
  - 요구 분석 명세서의 내용을 설계서에 모두 포함해야 한다.
  - 유지보수가 용이하도록 추적이 가능해야 한다. 
  - 변화에 쉽게 적응할 수 있어야 한다. 
  - 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다. 
  - 설계서는 읽기 쉽고, 이해하기 쉽게 작성해야 한다. 

- 설계의 원리 
  - 분할과 정복 
  - 추상화 
  - 단계적 분해 
  - 모듈화 
  - 정보은닉 

★ 아키텍처 구축 절차 
  - 요구 사항 분석 -> 아키텍처 분석 -> 아키텍처 설계 -> 검증 및 승인 

- 아키텍처 4+1 관점 
  - 논리적 관점, 구현 관점, 배치 관점, 프로세스 관점, 유스케이스 관점 

- MVC 모델 
  - Model, View, Controller
  - Controller가 Model로 데이터를 보내고 Model이 데이터를 처리해서 Controller로 데이터 전송 
  - Controller는 View에 데이터를 띄워주고 View에서 처리하는 데이터를 받아서 Model로 보내는 구조로 돌아간다.
  - 중앙 데이터 구조 

  - 장점 
    - 관심의 분리 
    - 데이터를 화면에 표현하는 디자인과 로직을 분리함으로써 느슨한결합 가능 
    - 구조 변경 요청 시 수정 용이 

  - 단점 
    - 기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가 
    - 속도가 중요한 프로젝트에 부적합 

- 모듈 
  - 규모가 큰 것을 여러 개로 나눈 조각 
  - 소프트웨어 구조를 이루는 기본적인 단위 
  - 하나 도는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합 
  - 독립 프로그램도 하나의 모듈, 함수들도 하나의 모듈 

- 모듈화의 특징 
  - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다. 
  - 유일한 이름이 있어야 한다. 
  - 독립적으로 컴파일이 가능하다. 
  - 모듈에서 또 다른 모듈을 호출할 수 있다. 
  - 다른 프로그램에서도 모듈을 호출할 수 있다. 

- 모듈화의 장점 
  - 분할과 정복의 원리가 적용되어 복잡도가 감소한다. 
  - 문제를 이해하기 쉽게 만든다. 
  - 변경하기 쉽고, 변경으로 인한 영향이 적다
  - 유지보수가 용이하다. 
  - 프로그램을 효율적으로 관리할 수 있다. 
  - 설계 및 코드를 재사용할 수 있다. 

- 바람직한 설계 
  - 모듈 간에는 꼭 필요한 데이터만 주고받도록 
  - 적은 인터페이스의 수를 통한 약한 결합 유지 
  - 매개변수로 제어 플래그보다 데이터를 사용 -> 유지보수 용이성 향상 
  - 낮은 결합도, 높은 응집도 

- 프로세스, 데이터 지향 방법의 문제점 
  - 변경이 미치는 영향이 큼 
  - 프로그램의 복잡도 증가 
  - 프로그램 변경 시 프로그램 구조 파악 필요 
  - 재사용의 어려움 

- 객체지향 방법 
  - 프로세스 지향 방법과 데이터 지향 방법의 문제점을 해결하기 위해 고안 
  - 기능이나 데이터 대신 객체가 중심이 되어 개발 
  - 데이터를 가장 먼저 찾고 그 데이터를 조작하는 메서드를 찾아 그 둘을 객체라는 이름으로 묶어 그 객체를 중심으로 모듈을 구성 

- 객체지향 방법의 특징 
  - 실세계를 사람이 생각하는 방식으로 표현한다. 
  - 임의로 데이터에 접근할 수 없다. 
  - 시스템은 객체들의 모임이다. 
  - 요구사항 변경에 유연하게 대처할 수 있다. 
  - 확장성과 재사용성이 높아진다.
  - 추상화를 통한 생산성과 품질이 높아진다. 

- 객체지향의 개념 과 특징 
  - 특징 : 캡슐화, 정보은닉, 상속, 다형성 
  - 개념 : 객체, 클래스, 인스턴스 

- 메소드 오버로딩 
  - 한 클래스에서 이름이 동일한 메소드가 정의 되어 있는 경우 
  - 구별하는 방법은 매개변수의 타입이 다르거나 개수가 다르다. 

- 메소드 오버라이딩 
  - 상속에서 일어나는 것으로 부모가 가지고 있는 메소드를 자식이 똑같이 가지고 있으면서 
  - 부모 것을 무시하고 자신의 것을 사용하는 것을 말한다. 

- 둘의 차이점 
  - 메소드 오버로딩 : 추상 클래스와 추상 메서드만 사용 
  - 메소드 오버라이딩 : 추상 클래스와 일반 클래스를 모두 다 사용 

- 테스트 절차 
  - 테스트 계획 -> 테스트 케이스 설계 -> 테스트 실행 및 측정 -> 테스트 결과 분석 -> 오류 추적 및 수정 

- 시각에 따른 테스트 
  - 확인 테스트 
    - 각 단계에서 개발자의 시각으로 테스트 
    - 설계도 대로 만들었는지 테스트 
    - 이전 단계에서 생성된 산출물이 현 단계의 산출물에 정확히 반영되었는지 테스트 

  - 검증 테스트 
    - 사용자의 요구 사항대로 만들었는지를 테스트 
    - 소프트웨어가 사용자의 목적에 맞게 구현되었는지 확인 

- 프로그램 실행 여부에 따른 테스트 
  - 정적 테스트 
    - 프로그램을 실행하지 않고 코드를 검토하며 오류를 찾는 방법 
  - 동적 테스트 
    - 프로그램을 실행하면서 오류를 찾는 방법 

- 정적 테스트 
  - 프로그램 코드를 실행하지 않고 여러 참여자가 모여 소프트웨어 개발 중에 생성되는 모든 명세서나 코드를 검토해서 실패 보다는 결함을 찾아내는 방법 

- 동적 테스트 
  - 명세 기반 테스트 ( 블랙박스 테스트 ) 
    - 입력 값에 대한 예상 출력 값을 정해놓고 그대로 결과가 나오는지를 체크 
    - 프로그램 내부의 구조나 알고리즘을 보지 않고, 여구 분석 명세서나 설계 사양서에서 테스트 케이스를 추출하여 테스트 
    - 사용자가 원하는 기능을 수행하는가 테스트 

  - 구현 기반 테스트 ( 화이트박스 테스트 ) 
    - 문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 분기/조건 검증 기준, 다중 조건 검증 기준, 기본 경로 테스트 

- V 모델 
  - 소프트웨어 개발 단계의 순서와 짝을 이루어 테스트를 진행해나가는 방법 
  - 프로젝트 초기 단계부터 테스트 계획을 세우고, 테스트 설계 과정이 함께 진행 
  - 요구 분석 -> 아키텍처 설계 -> 모듈 설계 -> 구현 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트 

- 통합 테스트 
  - 하향식 기법 
    - 깊이 우선 방식 ( BFS ) : 위에서 부터 탐색 ( 아래로 가며 통합 ) 
    - 넓이 우선 방식 ( DFS ) : 위에서 부터 탐색 같은 라인부터 탐색 ( 옆으로 가며 통합 ) 

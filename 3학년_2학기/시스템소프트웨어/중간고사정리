- 1020
- 중간고사 정리 

- 소프트웨어의 이해 
  - 프로그램
    - 원시코드 ( source code )

  - 소프트웨어 
    - 원시코드 
    - 모든 산출물 ( 자료구조, DB 구조, 테스트 결과 )  
    - 각 단계마다 생산되는 문서 
    - 사용자 매뉴얼 

- 소프트웨어의 분류 ( 관리, 제어, 임베디드 ) 
  - 관리 소프트웨어 
    - 자료를 받아들여 가공한 후 정보를 제공하는 소프트웨어 
    - 주로 DB에 자료를 저장한 후 검색을 통해 사용자가 원하는 형태로 정보를 제공 

  - 제어 소프트웨어 
    - 각종 센서를 이용하거나 기기들의 동작을 제어하는 소프트웨어
    - 사용자 메뉴얼 

  - 임베디드 소프트웨어   
    - 장비나 기기에 내장된 형태의 소프트웨어 

- 소프트웨어 특징 
  - 개발
    - 개인 능력 별 결과물의 차이가 있음 
  - 품질저하 
    - 하드웨어 H/W : 오래사용하면 부품이 닳는다, 고장 발생 빈도가 높다, 기능이 떨어진다. 
    - 소프트웨어 S/W : 오래 사용해도 닳지 않는다, 고장 발생 빈도가 낮다, 기능이 동일 

- H/W 실패 곡선 ( 욕조 곡선 ) 
  - 초기 실패율 높음 -> 오류해결 -> 오랜 기간 동안 사용 -> 주변 환경 문제 발생 -> 다시 실패율 증가 

- S/W 실패 곡선 
  - 초기 실패율 높음 -> 오류해결 -> 실패율 낮음 -> 변경 발생 -> 변경으로 인한 부작용 -> 실패율 급격히 증가 -> 다시 변경 발생 순환 

- 소프트웨어 당면 과제 
  - 소프트웨어 개발의 느린 발전 속도 
  - 새로운 소프트웨어에 대한 사용자 요구의 증가 
  - 관리 기술의 부분적 활용 

- 소프트웨어 개발 생명주기 ( SDLC : Software Development Life Cycle) 
  - 계획 -> 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 

- 계획, 요구분석 
  - 1단계 : 계획 
    - 개발 비용 산정 : COCOMO모델, 기능점수 모델 사용 
    - 일정 계획 : 작업분할구조도, CPM 사용 
    - 위험 관리 

  - 2단계 : 요구분석 
    - 기존 시스템의 문제점 파악 -> 새로운 요구사항 도출 -> 다이어그램 작성 
    - 개발에 따른 표현 도구 
    - 최종 산출물 : 요구 분석 명세서 

  - 3단계 : 설계 
    - 설계 원리 : 분할과 정복, 단계적 분해, 모듈화, 정보은닉
    - 아키텍처 스타일 
    - 모듈 평가 기준 : 응집도와 결합도 

  - 4단계 : 구현 
    - 간략한 프로그래밍 언어의 역사 
    - 표준 코딩 규칙 

  - 5단계 : 테스트 
    - 테스트의 절차 
    - 사용되는 목적에 따른 분류 
    - 품질 특성에 따른 분류 
    - 소프트웨어 개발 단게에 따른 분류 

  - 6단계 : 유지보수 
    - 수정 유지보수 
    - 적응 유지보수 
    - 기능보강 유지보수 
    - 예방 유지보수 

- 소프트웨어 개발 프로세스의 이해 
  - 프로세스 
    - 일을 처리하는 과정 또는 순서 
    - 주어진 일을 해결하기 위한 목적으로 그 순서가 정해져 수행되는 일련의 절차 

  - 좁은 의미 소프트웨어 개발 프로세스  
    - SW제품을 개발할 때 필요한 절차, 과정, 구조 
    - 사용자의 요구사항을 SW시스템으로 구현하기 위한 일련의 활동 

  - 넓은 의미 소프트웨어 개발 프로세스 
    - 절차, 구조, 방법, 도구, 참여자까지 모두 포함 
    - SW개발 목적을 이루는데 필요한 통합적인 수단 

- 주먹구구식 모델 
  - 정확한 앞뒤 계산 없이 일을 대충 처리할 때 쓰는 말 
  - 공식적인 가이드라인이나 프로세스가 없는 개발 방식 
  - 일단 코드를 작성하여 제품을 만들어본 후 요구분석, 설계, 유지보수에 대해 생각

  - 대학 수업의 한학기용 프로젝트 정도

  - 단점 
    - 관리및 유지보수가 어렵다.
    - 아키텍처를 만들 수도 없다. 
    - 프로젝트의 진척 상황을 파악할 수 없다. 
    - 수정이 매우 어려워 진다. 

★ 선형 순차적 모델 ( 폭포수 모델 ) 
  - 계획 -> 요구분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
  - 위 작업이 각 단계가 완벽하게 이루어지는 작업 모델 
  - 이론상 가장 완벽한 모델이다. 

  - 단점 
    - 각 단계의 결과물이 완벽한 수준으로 작성이되어야 다음 단계에 오류를 넘겨주지 않는다. 
    - 사용자가 중간에 가시적인 결과를 볼 수 없어 답답할 수 있다. 

- V 모델 
  - 폭포수 모델 + 테스트 단계 추가 확장 
  - 산출물 중심 ( 폭포수 모델 ) VS 각 개발 단계를 검증하는데 초점 ( V모델 )

  - 요구분석 -> 아키텍처 설계 -> 모듈설계 -> 구현 -> 단위테스트 -> 통합테스트 -> 시스템 테스트 -> 인수 테스트 

- 진화적 프로세스 모델 
  - 프로토타입 모델 
    - 대량 생산에 앞서 미리 제작해보는 원형 또는 시제품으로, 제자품 모형 
    - 사용자의 요구를 받아 일단 모형을 만들고 이 모형을 사용자와 의사소통 하는 도구로 활용 

  - 프로토타입 모델의 개발 생명주기 
    - 계획 -> 요구사항 정의 및 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
                    └> 요구수정 -> 빠른 설계 -> 프로토타입 개발 -> 고객평가 -> 프로토타입 조정 -> 구현 

  - 개발 절차 
    - 요구사항 정의 및 분석 
    - 프로토타입 설계 
    - 프로토타입 개발 
    - 사용자에 의한 프로토타입 평가 
    - 구현 

  - 장점 
    - 프로토타입이 의사소통 도구로 활용 
    - 반복되는 요구사항 정의를 통해 사용자 요구가 충분히 반영된 요구 분석 명세서 작성 
    - 초기 프로토타입 사용을 통한 새로운 요구사항 발견 
    - 프로토타입 사용을 통한 완성품의 예측 가능  

★ 나선형 모델 
  - 진화적 프로토타입 모델 + 위험 분석 
  - 계획 및 요구분석 -> 위험분석 -> 개발 -> 사용자 평가를 계속 지속적으로 반복 ( 1차 -> 2차 ... 이런한 방식으로 )
  
  - 위험 분석 단계의 위험 요소 
    - 빈번히 변경되는 요구사항 
    - 팀원들의 경험부족 
    - 결속력이 떨어지는 팀워크 
    - 프로젝트 관리 부족 

  - 나선형 모델 개발 절차 
    - 1. 계획 및 요구분석
      - 사용자의 개발 의도 파악 
      - 프로젝트의 명확안 목표 
      - 제약 조건의 대안을 고려한 계획 수립 
      - 기능/비기능 요구사항 정의 및 분석 

    - 2. 위험 분석 단계 
      ★ 개발자의 이직         : 가장 위험한 부분 ( 개발자가 바뀌면 시간이 더 오래 걸리게 됨 ) 
      ★ 요구 사항 변경        : 가장 위험한 부분 ( 계속 요구사항이 추가되고 바뀌면서 개발이 늦어진다 )
      - 발주사의 재정적 어려움 
      - 예상을 빗나간 투입 인력 
      - 개발 기간 부족 
      - 개발비 초과 

    - 3. 개발단계
    - 4. 사용자 평가 단계 
      - 프로토타입 평가 -> 추가 및 수정 요구 -> 프로토타입 개발  ( 3단계 과정을 반복 )

  - 장점 
    - 사전 위험 분석을 통한 돌출 위험 감소 
    - 사용자 평가에 의한 개발 방식 

  - 단점 
    - 반복적 개발에 의한 프로젝트 기간 연장의 가능성 
    - 반복 회수의 증가에 따른 프로젝트 관리의 어려움 
    - 위험 관리의 중요 

- 단계적 개발 모델 
  - 릴리즈 구성 방법에 따른 분류 
    - 점증적 개발 방법 
      - 개발 범위 증가 : 하나가 끝나면 그 다음, 또 끝나면 그 다음과 같이 하나씩 늘려 감 
      - 도서 집필 시 1장 부터 완벽히 작성하여 10장까지 순서대로 집필 

    - 반복적 개발 방법   
      - 품질 증가 : 하나가 끝나면 그 다음, 또 끝나면 그 다음과 같이 하나씩 늘려 감 
      - 도서 집필 시 1~10장까지 1차원고 작성 다시 1장으로 가서 2차 집필 시작.. 반복 

- 통합 프로세스 모델 
  - 1. 도입 단계
    - 비지니스 모델링 
    - 요구 사항 정의 

  - 2. 구체화 단계
    - 요구 사항 정의가 어느정도 끝나고 
    - 분석 및 설계 단계 
    - 어느정도 구현시작 

  - 3. 구축 단계
    - 구현단계가 활발이 이루어짐  
    
  - 4. 전이 단계 
  - 5. 도입/구체화/구축전이 단계의 공통 작업

★ 애자일 프로세스 모델 
  - 고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론 

  - 애자일의 기본 가치 
    - 프로세스와 도구 중심이 아닌, 개개인과의 상호 소통 중시 
    - 문서 중심이 아닌, 실행 가능한 소프트웨어 중시 
    - 계약과 협상 중심이 아닌, 고객과의 협력 중시 
    - 계획 중심이 아닌, 변화에 대한 민첩한 대응 중시 

  - 애자일의 개발 방법 
    - 프로토타입 개발 -> 사용자 확인 -> 일부 기능 사용 

  - 스크럼 개발 프로세스 
    - 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리를 위한 애자일 방법론 
    - 경험적 관리 기법 중 하나 
    - 구체적인 프로세스를 명확하게 제시하지 않음 
    - 개발 팀을 운영하는 효율적인 운영 방식 

  - 스크럼 방식에서 사용되는 용어 
    - 제품 기능 목록 작성 
      - 우선순위가 매겨진 사용자의 요구 사항 목록 

    - 사용자 스토리작성 및 스토리 포인트 산정 
      - 사용자 스토리 : 메모지 한 장에 구현할 기능을 사용자 관점에서 사용자 언어로 작성한 사용자 요구 사항 
      - 사용자 포인트 : 사용자 스토리를 수행하는데 걸리는 상대적인 개발 기간 

    - 스프린트 
      - 작업량으로 볼 때 그렇게 많지 않고, 개발 기간도 짧다 
      - 작은 단위의 개발 업무를 단기간 내에 전력질주하여 개발한다는 뜻 

    - 소멸 차트 
      - 시간이 지남에 따라 소멸되고 남은 것을 표현 
      - 계획 대비 작업이 어떻게 진행되고 있는지를 날짜별로 남은 작업량으로 표현 

  - 스크럼 방식의 장점 
    - 실행가능한 제품을 통해 사용자와 충분한 의견 조율 가능 
    - 일일 회의를 통한 팀원들 간의 신속한 협조와 조율 가능 
    - 일일 회의 시 직접 자신의 일정 발표를 통한 업무 집중 환경 조성 
    - 다른 개발 방법론들에 비해 단순하고 실천 지향적 

  - 스크럼 방식의 단점 
    - 추가 작업 시간 필요 
    - 일일 스크럼 회의를 15분 안에 마쳐야 함 
    - 투입 공수 불측정에 따른 효율성 평가 불가 
    - 프로세스 품질 평가 불가 

==============================================================================================================
- 계획 

- 소프트웨어 개발 계획 
  - 비용, 기간, 자원 계획 필요 

- 문제의 정의
  - 소프트웨어 개발의 첫 작업 
  - 무엇을 개발할 것인지 명확히 정의
  - 개발 범위를 결정

  - 개발하고자하는 영역의 배경지식이 필요 
  - 문제를 파악하기 위해 현재 운영 중인 시스템을 사용해본다. 
  - 실무 담당자와 면담하여 자료를 수집한 후 면밀히 분석해본다. 

- 타당성 분석 ( 경제적, 기술적, 법적 )
  - 경제적 타당성   
    - 경영자 : 투자 효율성에 관심 
    - 분석가 : 투자 대비 효과 검토 후 경영자에게 정확한 정보 제공 
    - 시장 분석을 통한 시장성 확인 

  - 기술적 타당성 
    - 현재의 기술로 사용자가 요구하는 기능을 구현할 수 있는지 검토 
    - 하드웨어 성능이 개발에 지장은 없는지 검토 
    - 개발자의 기술력에 문제가 없는지 검토 

  - 법적 타당성 
    - 개발용 소프트웨어와 도구의 사용이 법적으로 문제가 없는지 검토 
    - 지적 소유권과 프로그램 보호법이 강화되었으므로 법적인 문제를 꼭 검토 

- 개발 비용 산정 
  - 전자 제품 생산 비용 예측 
    - 생상 제품의 형상의 명확화 
    - 제조 원가의 명확화 

  - 건축 비용 예측 
    - 자재비, 인건비의 정확한 예측 가능 
    - 전체 비용 정확한 산출 

  - 소프트웨어 개발 비용 예측 
    - 개발자가 중심 
    - 개발자의 능력에 따른 생산성의 차이 
    - 다양한 개발 프로세스로 인한 표준화/자동화의 어려움 
    - 명확한 개발비 산출의 어려움 

- SW 개발 비용에 영향을 주는 요소 
  - 프로그램 자질
    - 초보 프로그래머와 고급 프로그래머의 생성산 차이가 큼 

  - 소프트웨어 복잡도 
    - 브룩스의 법칙 : 애플리케이션 개발 < 유틸리티 개발 < 시스템 프로그램 개발 

  - 소프트웨어 크기
    - 참여 인력 증가, 개발 기간 길어짐, 복잡도 커짐 

  - 가용 시간 
    - 인력/자원 증가는 개발 기간 단축 ( 정상적인 계획에서는 최대 75%가 줄일 수 있는 한계

  - 요구되는 신뢰도 수준 
    - 높은 신뢰도의 소프트웨어 개발 : 개발 비용의 증가 

  - 기술 수준 
    - 고급언어 사용 : 저급 언어의 사용보다 5~10배의 생산성 증가 

- 비용 산정 기법 

  ★ 하향식 산정 기법
    - 전문가 판단 기법 
      - 경험이 많은 전문가가 개발 비용을 산정 -> 신뢰성 높음 
      - 짧은 기간에 개발비를 산정하거나 입찰에 응해야 하는 경우 많이 사용 
      - 단점 : 수학적 계산 방법보다 경험에만 의존할 경우 부정확할 수 있음 

    ★ 델파이 기법 
      - 전문가 판단 기법을 보완한 기법이다. 
      - 전문가 비용 산정 -> 전문가 의견 -> 전문가 의견 일치? -> 비용 결정 
      - 전문가의 의견이 일치하지 않으면 다시 비용 산정부터 시작한다. 

  ★ 상향식 산정 기법 
    - 세부 작업 단위별로 비용 산정 후 전체 비용 합산 
    - 단점 : 수학적 계산 방법보다 경험에만 의존할 경우 부정확할 수 있음 

    - 원시 코드 라인 수 기법 
      - 원시 코드 라인 수의 비관치, 낙관치, 중간치를 측정한 후 예측치를 구해 비용 산정 
      - 비관치 : 라인 수를 가장 많게 생각할 때의 예상 라인수 
      - 낙관치 : 라인 수를 가장 적게 생각할 때의 예상 라인수 
      - 중간치 : 라인 수를 보통이라고 생각할 때의 예상 라인수 
      - 코드의 라인 수를 예측하고 비용을 산정하는 기법 

    - 개발 단계별 노력 기법 
      - 생명주기의 각 단계별로 노력을 산정 
      - M/M을 소프트웨어 개발 생명주기의 각 단계에 적용하여 단계별로 산정 
      - 장점 : 코딩만 대상으로 산정하는 LOC보다 더 정확 

  ★ 수학적 산정 기법 
    ★ COCOMO 방법 
      - SW규모를 예측한 후 SW 종류에 따라 각 비용 산정 공식에 대입하여 비용 산정 
      - 라인 수 중심의 개발비 산정 

      - 개발자의 특성이 높을 수록 비용이 적게 든다. 
      - 왜냐 만드는 속도가 빠르기 때문에 

      - COCOMO 방법을 이용한 총 개발 기간 산정 과정 
        - 가중치 반영하기 
        - 보정 계수 반영하기 
        - 총 개발 기간 산정하기 

      - 프로젝트 유형 
        - 단순형 프로젝트 
          - 복잡도와 난이도가 비교적 높지 않은 업무용 소프트웨어 
          - 크기는 중소 규모 정도, 크기는 50KDSI 이하 

        - 중간형 프로젝트 
          - 규모나 복잡도가 중간급 정도, 300KDSI 이하 
          - 운영체제, 데이터베이스 관리 프로그램 

        - 내장형 프로젝트 
          - 자동화 기기, 전자 제품과 같은 하드웨어와 밀접하게 관련있는 소프트웨어 
          - 크기 300KDSI 이상 

      - 프로젝트 진행 정도에 따른 분류 
        - 1단계 : 애플리케이션 합성 모델 
        - 2단계 : 초기 설계 모델 
        - 3단계 : 구조 설계 이후 모델 

    ★ Putnam 방법 
      - 소프트웨어 생명주기의 전 과정에 사용될 노력의 분포를 가정해 주는 

    - 기능 점수(FP) 방법 
      - 기능 점수를 구한 후 이를 이용해 비용 산정 

- 일정 계획 
  - 작업 분할 구조도 
    - 프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화하는 작업 
    - 프로젝트 구성 요소들을 계층구조로 분류 
    - 프로젝트의 전체 범위 정의
    - 프로젝트 작업을 세분화 

  - 작업 패키지 
    - 계층 구조에서 최하위에 있는 항목 

  - PERT/CPM
    - 작업순서, 소요 기간등을 네트워크 형태의 그래프로 표현한 후 어떤 작업이 중요한지, 또 일정에 여우가 있는 작업은 어떤 것인지 찾아내 중점 관리를 해야하는 작업을 명확히 하는데 사용 

    - CPM 네트워크 
      - PPT 3장 p.71 확인 
      - 일할 순서를 표로 그려둔 모양 

    - ES 값 
      - 가능한 빨리 시작할 수 있는 시간으로, 선행 작업이 완료되었을 때 해당 작업을 시작할 수 있는 가장 빠른 시점 
      - ES 값을 구할 때는 맨 앞 작업에서 끝 방향으로 가며 계산 

    - EF 값 
      - 가장 빠른 시작 시간(ES)으로 시작했을 때의 가장 빠른 완료 시간 
      - 즉, 가능한 빨리 끝낼 수 있는 시간으로 'ES + 작업 소요 시간' 

    - LS 값 
      - 어떤 작업을 늦어도 시작해야 하는 시간, 즉 가장 늦게 시작할 수 있는 시간 
      - 이 시간에 시작하지 않으면 총 일정 지연 

    - LF 값 
      - 가장 늦게 시작할 수 있는 시간(LS)에 시작해 작업을 완료할 시간 
      - 즉, 작업을 가장 늦게 끝낼 수 있는 시간으로 'LS + 작업 소요 시간'

    - ST 값 
      - 여유있는 시간, 느슨한 시간 
      - LS - ES로 값을 구한다. 

- 임계 경로 
  - CPM 네트워크 표에서 
  - ST 값에서 여유시간이 0인 값들의 경로를 그린다. 

- 간트 차트 
  - 프로젝트 일정 관리를 위한 바형태의 도구 
  - 계획된 작업량과 현재까지의 작업량을 가로막대그래프 형태로 그려둔것 

- 위험 분석 
  - 위험 관리 절차 
    - '위험 요소 식별 -> 위험 분석 -> 위험 계획 수립 -> 위험 감시 -> 위험 분석'으로 되돌아감 

    - 위험 요소 식별 : 잠재적인 위험 목록 
    - 위험 분석 : 중요도가 결정된 위험 목록 
    - 위험 계획 수립 : 대응 방안 결정 
    - 위험 감시 : 적절성 평가 

  - 위험 요소 식별 
    - 개발자의 이직             : 프로젝트 수행 중 개발자들이 이직한다. ( 가장 위험한 요소 ) 
    - 요구 사항 변경            : 요구 사항 확정 이후에도 변경 요구가 계속 된다. ( 개발 기간이 길어진다 ) 
    - 발주사의 재정적 어려움     : 프로젝트 수행 중 고객사에 경제적인 어려움이 발생 
    - 예상을 빗나간 투입 인력    : 처음에 예측한 인력보다 인력이 더 많이 필요하다. 
    - 개발 기간 부족            : 처음에 예측한 개발 기간을 초과한다. 
    - 개발비 초과               : 처음에 에측한 개발비로 개발을 완료할 수 없다. 

  - 위험 관리 절차 
    - 위험 요소가 발생할 가능성과 영향력 판단 
    - 경험이 많은 개발자의 의존해 판단

    - 위험 발생 가능성의 척도 
      - 매우낮음(10%<), 낮음, 보통, 높음, 매우높음(>75%)

    - 위험 발생 확률 
      - 상 : 80% 이상, 중 : 30% ~ 80%, 하 : 30% 미만 

  - 위험 계획 수립 
    - 식별된 위험 요소의 위험을 관리하기 위해 전략을 찾는 과정 
    - 위험을 처리하는 위험 대응 방안 수립 

  - 위험 감시 
    - 식별된 위험 요소의 발생 확률과 변화 등을 관리 
    - 예측한 위험의 실제 발생 여부 확인 
    - 실전에서 위험 대응 방안의 적절성 여부 확인 
==============================================================================================================
- 요구 분석 

- 요구 사항과 요구 분석 명세서의 이해 
  ★ SW 개발의 목적 
    - 개발된 소프트웨어의 고객 만족 

  ★ 고객 만족을 위한 특성 
    - 적시성 : 빠른 출시를 통한 시장의 점유 
    - 유연성 : 다양한 환경에서의 적응성 
    - 통합 : 기존 시스템과의 쉬운 통합 

  ★ 고객 만족의 개발 조건 
    - 고품질의 제품 개발 
    - 정해진 기간내의 개발 
    - 주어진 예산내의 개발 

- 요구 사항 / 요구 분석 명세서 
  - 요구사항 
    - 이용자가 어떤 문제를 풀거나 목표를 달성하기 위해 필요한 조건이나 능력 
    - 사용자와 개발자 간에 합의한 개발 범위에서 시스템이 제공해야 하는 기능 

  - 요구 분석 명세서 
    - 개발 초기에 사용자의 요구 사항을 추출하여 정리한 문서 
    - what 에만 초점, how는 고려하지 않음 

- 요구 분석의 이해
  - 요구 분석 과정 
    - 사용자 요구 파악 -> SW 목표 수립 -> 모델링 -> 요구 분석 명세서 

  ★ 요구 분석 
    - 소프트웨어 요구 사항 정의를 위해 사용자의 요구 사항을 조사하고 확인하는 과정 
    - 소프트웨어 개발 생명주기의 첫 단계
    - 소프트웨어 개발 성패의 열쇠 

- 요구 분석 관련자의 역할과 의미 
  - 




시험문제로 자바의 상속은 어떻게 쓰는가 ( 시험에 나올 가능성이 있음 )
  - extends 를 사용 

자바의 class는 Package 안에 작성 
자바에서 class 문을 가져다 쓰기 위해서는 import를 해야한다.

자바에서의 상속(Inheritance)
  - 특수화 (Specialization)
    - topdown 관점에서 봤을 때 특수화 
    - 상세한 객체 타입들로 세분화 될 수 있다
  - 일반화 (Generalization)
    - bottomup 관점에서 봤을 때 일반화 
    - UML에서 보편적으로 사용한다 
  
  - 용어
    - 슈퍼 클래스와 서브 클래스 
    - 부모 클래스와 자식 클래스
    - 베이스 클래스와 유도(파생) 클래스 
    
- 자바에서는 public class 이름이 file 이름이 된다. 
- file 이름이 되기때문에 public class는 하나만 존재 
- main 함수를 갔는 class는 반드시 public class 여야 한다. 
- object class가 java의 최상위 class이다.
- 자식은 부모클래스의 메소드를 실행 가능 

1교시 
<=====================================================================================>
package ex_1;

public class Person {
	String name;
	private String address;
	private String SSN;
	private String DOB;
	private String phone;
	
	public Person(String name, String address, String phone) {
		this.name = name;
		this.address = address;
		this.phone = phone;
	}
	
	public String getName() {
		return name;
	}

	public void printLabel() {
		System.out.println("hi");
	}
	public void changeAddress(String addr) {
		address = addr;
	}
}

class Student extends Person{
	public Student(String name, String address, String phone) {
		super(name, address, phone);
		this.major = "소프투웨어공학";
		this.minor = "안녕";
		this.advisor = "안녕2";
	}
	
	public String getName() {
		return name;
	}
	
	private String major;
	private String minor;
	private String advisor;
	private String GPA;
	private String courseeTaken;
	
	
	
	public void printTranscript() {
		System.out.println("오늘 점심 지지고 ㄱㄱ");
	}
}
<=====================================================================================>
package ex_1;

public class Controller {
	public static void main(String[] args) {
		Person p = new Person("김덕윤", "경기도 의정부", "010-1234-5678");
		System.out.println("p 객체의 이름 = " + p.getName());
		p.printLabel();
		
		Student s = new Student("정찬영", "경기도 의정부", "010-1111-2222");
		System.out.println("s 객체의 이름 = " + s.getName());
		s.printLabel();					// 메시지라고 한다
		s.printTranscript();
	}
}
<=====================================================================================>
package test;


public class Parent {
	String name;
	int age;
	String phone;
	
	Parent(String name, int age, String phone){
		this.name = name;
		this.age = age;
		this.phone = phone;
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
}

class Child extends Parent{
	private String hobby;
	Child(String name, int age, String phone) {
		super(name, age, phone);
	}
	public void setHobby(String hobby) {
		this.hobby = hobby;
	}
	public String getHobby() {
		return hobby;
	}
}
<=====================================================================================>
package test;

public class Controller {
	public static void main(String[] args) {
		Parent p = new Parent("정찬영", 23, "010-1234-678");
		
		System.out.println("p 객체의 이름, 나이 = " + p.getName() + " " + p.getAge());
	
		Child c = new Child("김덕윤", 22, "010-4321-8765");
		
		System.out.println("c 객체의 이름, 나이 = " + c.getName() + " " + c.getAge());
		c.setHobby("메이플");
		System.out.println("c 객체의 취미 = " + c.getHobby());
	}
}
<=====================================================================================>


2교시 
<=====================================================================================>
UML에서의 상속에는 자식 UML에 부모 메소드를 적지 않는다

★ 상속의 이점 
- 확장성이 좋다
- 유지보수성이 좋다 
- 재사용성이 좋다 
- 이해가 용이하다
- 추상화가 높아진다
- 대치성이 가능하다 

- 상향형변환 ( upcasting )
  - 상속의 환상적 장점
  - 슈퍼클래스의 객체는 서브 클래스의 객체로 대치 가능 

★ 오버로딩 과 오버라이딩 
  - 오버로딩 : 한 클래스 안에서 중복된 함수를 사용하는것. 단, 중복된 함수는 매개변수가 달라야한다.
  - 오버라이딩 : 상속이 무조건 있어야 하고, 부모와 자식이 서로 중복된 함수를 사용하는 것을 말한다.
  
<=====================================================================================>  
  package test_1;

class Instrument{
	public void play() {
		System.out.println("Instrument playing...");
	}
	public static void tunet(Instrument x) {
		x.play();
	}
}

public class Wind extends Instrument {

	public static void main(String[] args) {
		Instrument i = new Instrument();
		Instrument.tunet(i);
		
		Wind w = new Wind();		
		Instrument.tunet(w);
	}
	public void play() {
		System.out.println("Wind playing...");
	}
}
<=====================================================================================>
  
- 추상 클래스 
  - 여러 클래스들에 중복적으로 존재하는 행위를 하나의 공통된 위치로 뽑아내는 장치
  - 각 클래스들의 공통적인 요소를 일반화 한것 ( ex) 악기는 타악기, 현악기, 관악기 등등 있다. 악기라는 것이 추상 클래스이다 ) 
  - 실제 객체는 만들수 없다. 
  
- 구체화 클래스 
  - 추상 클래스를 구체적으로 나누어 객체를 만들수 있는 클래스 ( ex) 악기는 타악기, 현악기, 관악기 등등 있다. 타악기, 현악기 등 이런것이 구체화 클래스 ) 
  - 서브 클래스들은 추상 클래스의 행위를 상속받아서 서브 클래스의 목적에 맞도록 재정의 할 수 있다.
  
- 추상 클래스 목적 
  - 모든 클래스들에 공통된 인터페이스를 생성하기 휘함 
  - 공통된 인터페이스는 서로 다른 클래스에서 서로 다르게 표현될 수 있다. 
  - 모든 서브 클래스의 메소드들은 동적 바인딩 메커니즘을 통해서 호출가능하다. 
  
- 두가지 용도 
  - 공통된 행위에 대한 full 함수 구현 
  - 공통된 행위에 대한 템플릿은 특정 서브 클래스 메소드들에 의해 정의 된다. 

- UML 에서는 '추상'클래스를 IsAdstrac를 체크 하여 이텔릭체로 바꿔서 표시 
- UML 에서는 '가상'클래스를 IsAdstrac를 체크 하여 이텔릭체로 바꿔서 표시 
- 부모가 IsAdstrac이면 자식은 무조건 그 메소드를 구현해야 한다. 
- IsAdstrac가 무조건 하나이상 있어야 추상클래스 이다

<=====================================================================================>

package test_2;

public abstract class Figure {
	public void setColor(String color) {
		System.out.println("Color를 변경합니다");
	}
	
	// 추상 함수 area() 정의 
	public abstract void area();
}

class Circle extends Figure{
	public void area() {
		System.out.println("원 면적을 계산합니다");
	}
}
class Rectangle extends Figure{
	public void area() {
		System.out.println("사각형 면적을 계산합니다");
	}
}
class Triangle extends Figure{
	public void area() {
		System.out.println("삼각형 면적을 계산합니다");
	}
}
<=====================================================================================>
package test_2;

public class Controller {
	public static void main(String[] args) {
		// 추상 클래스는 객체를 만들면 error 발생 
		//Figure f = new Figure();
		Circle c = new Circle();
		Rectangle r = new Rectangle();
		Triangle t = new Triangle();
		
		c.area();
		r.area();
		t.area();
    c.setColor("yellow");
		r.setColor("Red");
		t.setColor("Blue");
	}
}
<=====================================================================================>

- 추상클래스도 상속이 있어야 한다. 
<=====================================================================================>
package test_2;

public abstract class Figure {
	public void setColor(String color) {
		System.out.println("Color를 변경합니다");
	}
	
	// 추상 함수 area() 정의 
	public abstract void area();
}

class Circle extends Figure{
	public void area() {
		System.out.println("원 면적을 계산합니다");
	}
}
class Rectangle extends Figure{
	public void area() {
		System.out.println("사각형 면적을 계산합니다");
	}
}
class Triangle extends Figure{
	public void area() {
		System.out.println("삼각형 면적을 계산합니다");
	}
}
<=====================================================================================>
package test_2;

public class Controller {
	
	// 각 클래스를 하나로 묶어서 저장 
	static Figure[] figures = new Figure[3];
	static int i;
	public static void main(String[] args) {
		//추상 클래스는 객체를 만들면 error 발생 
		//Figure f = new Figure();
		
		Circle c = new Circle();
		Rectangle r = new Rectangle();
		Triangle t = new Triangle();
		
		c.area();
		r.area();
		t.area();
		c.setColor("yellow");
		r.setColor("Red");
		t.setColor("Blue");
		addFigure(c);
		addFigure(r);
		addFigure(t);
		areaFigure(c);
		areaFigure(r);
		areaFigure(t);
	}
	public static void addFigure(Figure f) {
			figures[i++] = f;
	}
	public static void areaFigure(Figure f) {
		for (int i=0;i<3;i++) {
			figures[i].area();
		}
	}
}

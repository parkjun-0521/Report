객체지향의 개요 

- 개발 패러다임
	- 객체지향 개념 
	- 객체지향 설계
	- 컴포넌트 설계
	- 서비스 지향 설계 

- 모델링 
	- 실체 시스템 -> 모델링 -> 모델 ( 요구사항, 분석, 설계 모델) -> 구현 -> 실제 시스템 

- 모델링의 목적 
	- 가시화 ( 원하는 모습으로 가시화 )  
	- 명세화 ( 구조화 행동을 명시화 ) 
	- 문서화 ( 분석 / 설계의 문서화 ) 
	- 구축화 ( 시스템을 구축하는 기본 형태 제공 )

- 모델링의 중요성 
	- 복잡한 현실세계를 이해하기 쉽도록 단순화하는 작업 
	- 비용의 절감 효과 

- 모델링 : 요구사항 정의 -> 분석 -> 설계 
- 프로그래밍 : 구현 

- 객체지향 개발 방법 
	- 실체 및 개념들을 객체라는 독립된 단위로 구성하고,
	  객체들이 메시지를 통하여 상호작용함으로써 전체 시스템이 운영 되는 개념 

- UML 
	- 설계도 같은 역할 
	- 목적 
	  - 객체지향 개념을 이용한 시스템 모델링 
	  - 소프트웨어 구조의 재사용 문제를 해결 
	- 기능 
	  - 요구정의단계에서 최종 테스팅에 이르는 단계 
	- 개념 
	  - 통합모델링 언어 
	  - 객체지향 시스템 개발 분야에서 가장 우수한 모델링 
	- 특징 
	  - 가시화 언어 
	  - 명세화 언어 
	  - 문서화 언어 
	  - 구축 언어

- 정적설계 : class들 간의 관계를 정의 
- 동적설계 : class들 간의 흐름을 정의

- 객체지향
	- 캡슐화 
	- 정보은닉
	- 인터페이스
	- 상속 
	- 클래스 
	등의 개념으로 구성 

- 객체 
	- 현실에 존재하는 것을 모두 말한다.
	- 소프트웨어 개발 대상을 말한다.

	- 객체는 데이터와 그 데이터를 처리하는 함수로 구성된 모듈 
	- 데이터는 객체의 상태를 제공
	- 함수는 객체의 행위를 의미

	- 객체는 추상화의 단위 

- 클래스 
	- 객체를 생성할 수 있는 구조와 정보를 가지고 있는 틀 

	- 모든 객체들이 공통적으로 갖는 상태와 행위를 기술하는 조감도
	- 클래스는 사용자 정의 타입으로 사용된다

	- 객체들에 대한 소스코드 조감도이다.
	- 객체 타입을 소프트웨어적으로 구현하는 장치 

- 캡슐화 
	- 관련된 데이터와 메소드를 하나의 클래스 속에 포함시키는 메커니즘 
	- 객체지향 언어에서만 존재하는게 아님 

- 정보은닉 
	- 특정정보를 외부에 노출시키지 않는 덧 
	- private으로 설정 

캡슐화는 단지 관련된 데이터와 함수들을 묶는 것 
정보은닉은 한 클래스 내의 세부사항을 숨기는 것

- 정보은닉 이점 
	- 추상화를 높여준다
	- 세부 알고리즘이 다른 객체에 영향을 주지 않고 변경시킬 수 있다.
	- 모듈의 독립성을 높여줌 
	- 유지보수성 향상 
	- 확장성을 높여줌 

- 메시지 
	- 객체들 사이의 상호작용 수단 
	- 다른 객체에게 특정 작업을 요청하는 신호

- 복합객체 
	- 포함 
	  - 한 객체가 다른 객체를 포함하는 관계 
	  - Aggregation 이라고 함 
	  - 복합 객체라고 한다 
	- 포함이 발생하는 경우 
	  - 클래스 내부 정의에서 		Aggregation
	  - 클래스 내의 객체 생성함수 내에서 	commposition
	  - 부분 객체를 실제 사용하기 직전 	association
	  - 포함의 강도 
	    - dependency -> association -> commposition -> aggregation

- 상속 
	- 특수화 
	  - 한 객체타입 보다 상세한 객체 타입들로 세분화 될 수 있다.
	  - 자식 클래스에서 재정의 하지 않고 부모클래스의 변수나 메소드를 사용 가능 

	- 일반화 
	  - 공통된 속성이나 함수들은 일반화시켜서 새로운 클래스를 정의할 수도 있다

	- 용어 
	  - 슈퍼클래스 , 자식클래스
	  - 부모클래스 , 자식클래스 
	  - 베이스클래스 , 유도(파생)클래스 
	
- Java 에서 상속 사용법 
	- extends 를 사용하여 상속을 표기 
	  - ex) class Person{}
	        class Student extends Person{} 
		이런 식으로 사용 
	- public 또는 protected 의 변수또는 메소드를 사용 가능  

	- 이점 
	  - 확정성이 좋다
	  - 유지보수성이 좋다
	  - 재사용성이 좋다 
	  - 이해하기가 용이하다
	  - 추상화가 높아진다
	  - 대치성이 가능하다 ( upcasting 매커니즘 사용 ) 

	- Upcasting ( 상향형변환 ) 
	  - 슈퍼클래스의 객체는 서브클래스의 객체로 대치 가능 

- 다중 상속 
	- 한 클래스의 부모 클래스가 둘 이상 존재 

- 추상 클래스 
	- 여러 클래스들에 중복적으로 존재하는 행위를 하나의 공통된 위치로 뽑아내는 장치 
	- 서브 클래스들은 추상클래스의 행위를 상속받아서 서브클래스의 목적에 맞도록 재정의 가능

	- 목적 
	  - 모든 클래스들에 공통된 인터페이스를 생성 
	  - 공통된 인터페이스는 서로 다른 클래스에서 서로 다르게 표현 가능 
	  - 모든 서브 클래스의 메소드들은 동적 바인딩 메커니즘을 통해 호출가능 

	- 용도 
	  - 공통된 행위에 대한 full 함수 구현 
	  - 서브 클래스 메소드들에 의해 정의 
	
	- 이점 
	  - 높은 재사용성 
	  - 유지보수성 향상 
	  - 확장성 향상

	- 사용법 
	  - 자바에서는 추상클래스를 만들기 위해 
	  - adstract 가 필요 

	- UML에서 표기 
	  - 추상클래스는 IsAdstrac을 체크 해서 이텔릭체로 바꿔야함 
	  - 가상클래스는 IsAdstrac을 체크 해서 이텔릭체로 바꿔야함 

	- 추상클래스는 상속이 있어야 한다.
	- 추상클래스는 무조건 가상함수가 하나는 있어야 한다 

- 인터페이스 
	- 한 인터페이스는 서로 관련 없는 객체들이 상호작용하기 위해 사용하는 도구 
	- 인터페이스는 메소드 선언들의 집합 

	- 사용법
	  - 자바에서는 인터페이스를 만들기 위해 
	  - Interface 키워드가 필요 
	  - ex ) public interface 인터페이스 이름 {}
	
	- 추상클래스와 공통점 
	  - 객체 생성이 불가능 하다
	- 추상클래스와 차이점 
	  - 인터페이스는 함수 선언만 가능 
	  - 추상클래스는 함수 정의와 함수 선언 모두 가능 
	  - 인터페이스는 변수 선언 불가능 
	  - 추상클래스는 변수 선언 가능 

- 다형성 
	- 두개 이상의 객체들이 동일 메시지에 대해 각자 반응하는 것 
	- 인터페이스롸 구현을 분리시키는 도구 
	
	- 유형 
	  - 메소드 오버로딩 
	  - 메소드 재정의 

	- 오버로딩 
	  - 서로다른 매개변수 타입이나 매개변수 개수를 지닌 동일한 메소드 이름이 존재 
	  - 여러 개의 메소드들이 한 클래스에서 중첩될 수 있다. 
 
	- 오버라이딩 
	  - 상속관계에서 발생하는 것으로 
	  - 부모의 메소드와 자식이 메소드가 완전이 같은것을 말한다. 

		



시험은 11시 
책은 가져오기 
기본적으로는 오픈북이 아님  

-다이어그램 종류
패키지 다이어그램
클래스 다이어그램
개체 다이어그램
복합 구조 다이어그램
구성 요소 다이어그램
배포 다이어그램
시퀀스 다이어그램
활동 다이어그램
사용 사례 다이어그램
통신 다이어그램
상태 다이어그램
상호 작용 개요 다이어그램
타이밍 다이어그램


- 가장 중요한 3가지 
클래스다이어그램 
유스케이스다이어그램 ( 사용 사례 다이어그램 ) 
시퀀스다이어그램

오늘할 예제 난이도 정도로 중간고사가 나옴 

	








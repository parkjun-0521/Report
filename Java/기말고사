1. call by value
- 자바에는 call by reference가 없다 
- call by value가 있다. 
- 매개변수가 기본타입으로 선언되었을 때는 실제 값은 변경되지 않는다. 
★매개변수가 객체의 레퍼런스만 전달하게 되면 실제 값이 변하게 된다.
★객체가 전달되는 경우는 실제 값이 변경이 된다. 
- 이처럼 객체가 매개변수로 넘어가는 경우 실제 값을 변경할 수 있다. 


2. 오버로딩 
- 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성 
★리턴 타입은 오버로딩과 관련이 없음 
★함수이름은 같되, 매개변수의 데이터형이 다르다거나 매개변수의 데이터 개수가 달라야 한다. 


3. 객체 치환 
★ 객체 치환은 객체 복사가 아니고, 레퍼런스 복사이다. 
★ ex ) Circle c1 = new Circle(2);
	Circle c2 = new Circle(6);
	Circle c99;

	c99 = c2;
	c1 = c2; 	// 객체 치환  => c1이 가리키는게 c2가 가리키고 있는것이 된다. 
	System.out.println(c1.get());		// 6 이 출력됨 
	System.out.println(c2.get());		// 6 출력 	


4. 객체 소멸 
- new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 머신으로 되돌려 주는 행위 
- 객체 생성 연산자 : new 
★자바에서 사용자 임의로 객체 소멸 안됨
★자바는 객체소멸 연산자가 없음 
★자바 가상 머신이 알아서 객체를 소멸한다. 


5. 가비지 
★가리키는 레퍼런스가 하나도 없는 객체 
- 더이상 접근할 수 없어 사용할 수 없게 된 메모리
- 가비지 찾을 수 있어야 한다. 
- PPT 4장 48쪽 이해완료 


6. 가비지 컬렉션 
- 자바 가상 머신이 가비지를 자동으로 수집 및 반환 
- 가비지 컬렉터에 의해 자동 수행 

- 강제 가비지 컬렉션 강제 수행 
 ★System 또는 Runtime 객체의 gc() 메소드 호출  => ex) System.gc(); 
 - 이 코드는 가비지 컬렉션에게 요청을 하는 것이므로 
 - 결국 자바가상머신이 가비지 컬렉션 시점을 전적으로 판단 하는 것 


7. 패키지 
- 상호 관련이 있는 클래스 파일을 저장하여 관리하는 디렉터리 
- 자바 응용프로그램은 하나 이상의 패키지로 구성 


8. 접근 지정자 
- 4가지 : private, protected, public, 디폴트( 접근지정자 생략 ) 
- 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용 
- 캡슐화정책으로 멤버를 보호하는 것 
- private : 자신의 클래스 내에서만 접근할 수 있다.  
- protected : 상속 관계에서 자신과 자식 클래스만 접근할 수 있다.
- public : 전체 공개 어디서든 접근할 수 있다.
- 디폴트 : 패키지 내에서는 다 접근할 수 있다. 

- 범위 : private < 디폴트 < protected < public 

★protected : 	같은 패키지 내의 다른 모든 클래스에게 접근 허용 
		상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능 


9. static 멤버 
- static 멤버 선언 
- static int i;		static void i() {...}

★static 멤버는 클래스당 하나만 생성 
- 객체들에 의해 공유됨 
- 클래스 멤버라고 부름 
- 클래스 로딩 시에 멤버가 생성된다. 
★객체가 생기기전에 이미 생성 
★객체가 사라져도 멤버는 사라지지 않음 
★프로그램이 종료될때 사라진다. 
- 동일한 클래스의 모든 객체들에 의해 공유됨 

- 활용 
- 전역 변수와 전역함수를 만들 때 활용 
- 공유 멤버를 만들고자 할 때

★static의 제약 조건 1
★static 메소드는 오직 static 멤버만 접근 가능 
- non-static 메소드는 static멤버 사용 가능 
- static 메소드는 non-static멤버 사용 불가능 

★static의 제약 조건 2 
★this 사용불가 
- 객체 없이도 사용 가능하므로 this레퍼런스를 사용할 수 없음 


10. 상속 
- 클래스의 간결화 
- 클래스 관리 용이 
- 소프트웨어 생산성 향상 
- 코드의 중복을 제거하여 클래스를 간결하게 구현
★extends 키워드로 선언 

★클래스 다중 상속은 불가능 
- 모든 자바 클래스는 묵시적으로 Object 클래스를 상속 받음 

★서브 클래스의 객체가 생성될 때 
 - 슈퍼클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행 

- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식 
 - 1. 개발자의 면시적 선택 
  ★super() 키워드 사용 
 - 2. 컴파일러가 기본 생성자 선택 

★super
 - 부모의 멤버에 접근
 - super.x 를 하면 현재 클래스의 부모 클래스에 있는 x값에 접근한다.
 - 서브클래스에서만 사용된다.  

★super() 
 - 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출 
 ★사용법 : super(매개변수); => 매개변수의 개수의 맞춰서 부모의 생성자가 호출 됨 
 ★반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 한다. 


11. 업캐스팅 
★서브 클래스를 슈퍼 클래스에 대입 
★ex ) 	Person p;
	Student s = new Student();
	p = s;		// 업캐스팅 => 자식을 부모에 대입 
- 업캐스팅은 명시적 타입 변환을 하지 않아도 됨 

★그렇다고 해서 부모가 자식의 멤버에 접근할 수 있는 것은 아님 
- 부모는 자신 이외에 접근할 수 없음 
★상속 관계에서만 발생한다. 


12. 다운캐스팅 
★업캐스팅된 것을 다시 원래대로 되돌리는 것 
★반드시 명시적 타입 변환 지정 
- ex )	Person p = new Student("A");	// 업캐스팅
	Student s = (Student)p;		// 다운캐스팅 + 강제형변환 
	Student s = p; 			// 에러발생 ( 형변환을 하지않았기 때문에 ) 


13. instanceOf 연산자 
★레퍼런스가 가리키는 객체의 타입 식별 
- 연산의 결과는 : true / false 로 반환 
★사용법 : ( 객체레퍼런스 instandeof 클래스타입 )
★ex ) 	Person p = new Professor();	// Professor 객체는 Researcher, Person을 상속 받음 
	if(p instanceof Person)		// true 반환 
	if(p instanceof Student)	// false 반환 => Student는 상속받고 있지 않기 때문에 
	if(p instanceof Researcher) 	// true 반환 
	if(p instanceod Professor) 	// true 반환 


14. 메소드 오버라이딩 
★서브 클래스에서 슈퍼 클래스 메소드를 중복 작성 
★항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보장 

- 조건 
 - 슈퍼 클래스 메소드의 원형과 동일하게 작성 
 
- 목적 
 ★오버라이딩으로 다형성 실현 
 - 하나의 인터페이스에 서로 다른 구현 
 - 서브 클래스에서 각 목적에 맞게 다르게 구현 


15. 동적바인딩  ( 서술형 문제 ) 
★실행할 메소드를 컴파일할 때 결정하지 않고 실행할 때 결정하는 것 
★동적바인딩을 통해서 서브 클래스에 구현되어 있는 오버라이딩 메소드가 항상 실행되도록 보장 
-----★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★----
- 동적바인딩은 메소드를 컴파일할 때 결정하는 것이 아닌 실행할 때 결정하는 것을 말한다. 
- 이것을 통해 서브 클래스에 구현되어 있는 오버라이딩 메소드가 항상 실행되도록한다. 
- 부모에 있는 메소드가 자식에게도 있다는 것을 확인하고 실행중에 자식의 것으로 결정하여 출력하는 것으로 
- 오버라이딩을 하면 동적바인딩이 이루어진다. 
-----★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★----


16. 추상클래스  
- 추상 메소드 
 ★abstract 키워드를 사용한다.
 ★abstract로 선언된 메소드.
 - 메소드의 코드는 없고 원형만 선언한다. 

- 추상 클래스 
 ★추상메소드를 가지며 , abstract로 선언된 클래스를 말한다. 
 - 추상메소드 없이, abstract로 선언한 클래스 

- 추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음 
★한마디로 객체생성이 불가능 하다. 

★추상클래스를 상속 받으면 추상클래스가 됨 
- 서브 클래스도 abstract로 선언해야한다. 

- 추상클래스 구현 
 ★서브 클래스에서 슈퍼클래스의 모든 추상 메소드를 오버라이딩하여 실행 가능한 코드로 구현하는 것 
 - 추상 클래스를 구현한 서브 클래스는 추상 클래스가 아니다. 


17. 인터페이스 ( ★interface )
★다중 상속을 지원하지는 않지만, 인터페이스로 다중 상속의 효과를 얻을 수 있다. 
- 클래스가 구현해야 할 메소드들이 선언되는 추상형 
★interface 키워드로 선언 
- 메소드를 선언만 가능하고 정의는 불가능하다. 
★인터페이스에는 멤버변수 선언 불가 
★단, default 메소드로 메소드를 정의할 수 있다. 

- 인터페이스의 구성요소 
 - 상수 : public만 허용
 - 추상메소드 : public static 생략 가능 
 - default 메소드 : public 접근 지정만 허용, 생략 가능 
 - static 메소드 : public, private 모두 지정 가능. 생략하면 public 

★인터페이스 특징 
 ★객체 생성 불가 
 ★인터페이스 타입의 레퍼런스 변수 선언 가능 

★인터페이스 상속 
 - 인터페이스 간에 상속 가능 
 ★extends 키워드로 상속 선언 
 ★인터페이스 다중 상속 허용 

- 인터페이스 구현 
 - implements 키워드 사용 
 - 여러개의 인터페이스 동시 구현 가능 

- 인터페이스끼리 상속 : extends 
- 클래스에 인터페이스 적용 : implements 


18. 패키지 개념 
- 패키지 
 ★서로 관련된 클래스와 인터페이스를 컴파일한 클래스파일들을 묶어 놓은 디렉터리 
 - 하나의 응용프로그램은 한개 이상의 패키지로 작성  
 ★패키지는 jar 파일로 압축할 수 있음 

- 모듈 
 - 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너 
 ★하나의 모듈을 하나의 .jmod 파일에 저장 
 - java9 부터 모듈들로 완전히 재구성 
 ★현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음 
 - 자바 JDK에 제공되는 모듈 파일들 


19. 패키지 사용하기 
★import문 
 ★소스 시작 부분에 import 패키지.클래스 
 - 이후에는 그냥 사용할 수 있음 

★import 패키지.*
 - 패키지에 있는 모든 파일을 import함 

★패키지 저장되는 곳 
 ★컴파일되면 클래스 파일 (.class) 생성 
 ★클래스 파일은 패키지로 선언된 리렉터리에 저장 

★패키지 선언 
 - 소스파일 맨 앞에 컴파일 후 저장될 패키지 지정 
 ★package 패키지명; 


20. 모듈 
- 패키지와 이미지 등의 리소스를 담은 컨테이너 
- 모듈 파일 .jmod로 저장 
- 자바 API의 모든 클래스가 여러 개의 모듈로 재구성됨 

★목적 
 - 자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함 
 - 컴퓨터 시스템의 불필요한 부담 감소 
 - 응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행환경 구축 


21. Object 클래스 
- 모든 자바 클래스는 반드시 Object를 상속받도록 자동 컴파일 
- 최상위 클래스, 모든 클래스의 수퍼 클래스 
- java.lang 패키지에 속함 
 ★boolean equals(Object obj) 	: obj를 가리키는 객체와 현재 객체가 같은지 비교  
 ★class getClass()		: 현 객체의 런타임 클래스 리턴 
 - int hashCode()
 ★String toString()		: 문자열 표현을 리턴 
 - void notify()
 - void notifyAll()
 - void wait()

★문자열 ( toString 메소드 작성 )
  public String toString() {
   return "출력할 문자";
  }

★객체 비교 ( == , equals ) 
 - == 연산자를 사용하면 서로객체끼리 같은지 판별이 안됨
 - 객체 레퍼런스만 비교하기때문에 서로 다르다고 판별 

★equals 사용 
 - 두 객체의 내용물 비교 
 - 클래스 작성자가 클래스에 equals() 메소드를 오버라이딩 해야 함 
 ★equals 메소드 작성 
  public boolean equals(Object obj) {
    Point p = (Point)obj; // obj를 Point 타입으로 다운 캐스팅
    if(x == p.x && y == p.y) return true;
   else 
    return false;
  }


22. Wrapper 클래스 
- 자바의 기본 타입을 클래스화한 8개 클래스를 통칭 
- 객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해서 
★ex ) 	기본타입 : Integer i = Inreger.valueOf(10);
	문자열 	 : Integer I = Integer.valueOf("10");
	Float 	 : Float f = Float.valueOf((double) 3.41);

- 자주 사용하는 주요 메소드  ( 나머지 기본 타입들도 int와 형식이 비슷함 ) 
 - int intValue();
 - static int parseInt(String s);

★문자열을 기본 데이터 타입으로 변환 
 - ex ) int i = Integer.parseInt("123");	// 문자 123을 정수형 123으로 바꿈 

★기본 타입을 문자열로 변환 
 - ex ) Stirng s1 = Integer.toString(123); 	// 정수 123을 문자열 123으로 바꿈 


23. String의 생성 
- String 클래스는 문자열을 나타냄 
★String 클래스는 문자열 변경이 불가능 
★따라서 메소드를 사용하여 문자열을 바꿈 
 
- 스트링 리터럴 
 - 자바 가상 머신 내부에서 리터럴 테이블에 저장되고 관리됨 
 - 응용프로그램에서 공유됨 

- new String()으로 생성된 스트링 
 - 스트링 객체는 힙에 생성 
 - 스트링은 공유되지 않음 
 - 공간을 약간 더 많이 차지함

★두 스트링을 비교 
 - 반드시 equals를 사용해야한다. 

★comrareTo()
 - 문자열이 같으면 0리턴 

★trim() 
 - 스트링 앞 뒤 공백을 제거하는 메소드 


24. StringBuffer 클래스 
★객체 생성 
 - StringBuffer sb = new StringBuffer("This");

★활용 
sb.append(" is pencil."); 	// sb = "This is pencil."
sb.insert(7, " my"); 		// sb = "This is my pencil."
sb.replace(8, 10, "your"); 	// sb = "This is your pencil."
System.out.println(sb); 	// "This is your pencil." 출력

★★★★★-------------------- String 과 StringBuffer의 차이 -------------------------★★★★★
★String 클래스와 달리 문자열 변경 가능 
★가변 크기의 버퍼를 가지고 있어서 문자열 수정 가능 
★문자열의 수정이 많은 작업에 적합 



25. StringTokenizer 클래스 
- 구분 문자를 기준으로 문자열을 분리하는 클래스 
- 토큰 : 구분 문자로 분리된 문자열 

- ex ) 	String query = "a=b=c=d=e+123";
	StringTokenizer st = new StringTokenizer(query, "=+");
	// 결과 a b c d e 123출력 
- (=,+) 를 토큰으로 구분하여 (=,+) 를 기준으로 문자열을 나눔 
- 토큰은 뭘 하든 상관이 없다. 


- int count = st.countToken();	// 토큰 개수 알아내기 => 결과 : 6
- String token = st.nextToken();// 다음 토큰 얻어내기 => 결과 : a 

- st.hasMoreTokens() => 다음 토큰을 불러오는 매소드 

- 토큰을 불러와서 출력 
while(st.hasMoreTokens()) { 	// 다음 토큰을 불러옴 
 String token = st.nextToken(); // 현재 토큰 얻기
 System.out.println(token); 	// 토큰 출력
}
// 토큰이 없으면 종료




26. Vector<E> ( 제네릭 ) 
- import java.util.Vector 을 해줘야한다. 

- 배열을 가변 크기로 다룰 수 있게 하고
- 객체 삽입, 삭제, 이동이 쉽도록 구성한 컬렉션 클래스 

- 배열의 길이제한 극복 
- 요소의 개수가 넘치면 자동으로 길이 조절 
- 삽입, 삭제에 따라 자동으로 요소들의 자리를 이동 

- 객체 생성 
- Vector<Integer> v = new Vector<Integer>();
- Vector<String> S = new Vector<String>();

// 초기에 크기 설정 
- Vector<Integer> v = new Vector<Integer>(5); 

- Vector에 객체 삽입 
 - 벡터의 맨 뒤, 중강에 객체 삽입 가능 

- Vector에서 객체 삭제 
 - 임의의 위치에 있는 객체 삭제 가능 

- boolean add ( E element )           : 맨뒤에 값 추가 
- void add ( int index, E element )   : 원하는 위치에 값추가 
- E elementAt(int index)              : index의 요소 리턴 
- E get(int index)                    : index의 요소 리턴 
- E remove(int index)                 : index의 요소 삭제 
- int size()                          : 벡터가 포함하는 요소의 개수 리턴 
- 단, 벡터는 size보다 큰 값을 삽입할 경우 오류가 발생 
ex) size가 4 (0,1,2,3 해서 4개) 인데  5번째에 값을 넣으라고 하면 오류발생 왜냐? size보다 크기 때문에 

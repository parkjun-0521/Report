세상의 모든 것이 객체다.

실세계 객체 특징 
  - 객체마다 고유한 특성, 행동을 가진다. 
  - 다른 객체와 정보를 주고 받고, 상호작용을 함 
  
객체지향의 특성 
- 캡슐화 : 객체를 갭슐로 싸서 내부를 볼 수 없게 하는 것 
  - 클래스 : 객체 모양을 선언한 틀 
  - 객체 : 생성된 실체 
- 상속 : 상위 개체의 속성이 하위개체에 물려짐 
  - 상위 클래스의 멤버를 하위 클래스가 물려받음 
- 다형성 : 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것 
  - 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드 
  - 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현 
  
클래스와 객체 
- 클래스 : 객체의 속성과 행위 선언 
  - 객체의 설계도 -> 클래스는 객체의 타입이다. 
  - 속성 -> 멤버 변수, 행동 -> 멤버 메소드 
  
- 객체 : 클래스의 틀로 찍어낸 실체           => 인스턴스 라고도 부름 
  - 프로그램 실행 중에 생성되는 실체 
  - 메모리 공간을 갖는 구체적인 실체 
  - '인스턴스'라고 부름 

클래스 
- class 키워드로 선언 
- 접근 지정자 : private, protected, public, 디폴드 

객체
1. 객체를 가리킬 레퍼런스 변수 선언 
  - 클래스명 객체이름;
  
2. 객체 생성 : new 연산자를 사용 
  - 객체이름 = new 클래스명();
  
3. 객체 멤버 접근 
  - 점(.) 연산자 사용 
  ex) 객체이름.show(); 
=========================================================================================================

생성자 개념과 목적 
- 객체가 생성될 때 초기화 목적으로 실행되는 메소드 
- 객체가 생성된는 순간에 자동 호출 
- 객체 생성시 초기화 

★ 기본 생성자 
- 매개변수가 없고, 실행 코드가 없어 아무일도 하지 않고 단순 리턴 하는 생성자 
- 디폴트 생성자라고 불린다. 

- 클래스에 생성자가 하나도 선언되어 있지 않을 때 기본생성자가 자동 생성된다.
- 단, 기본 생성자 없이 매개변수가 있는 생성자를 작성하면 에러가 뜬다. 
- 기본 생성자는 무조건 선언하고 코딩하는 것이 좋다. 


this 레퍼런스 
- 객체 자신에 대한 레퍼런스 
- this.멤버 형태로 멤버를 접근할 때 사용 

★ this()로 다른 생성자 호출 
- 같은 클래스의 다른 생성자 호출 
- 생성자 내에서만 사용 가능 
- 생성자 코드의 제일 처음에 있어야 함 


객체 배열 
- 자바의 객체 배열 
클래스명[] 객체명;
객체명 = new 클래스명[value];

// 객체 배열 초기화 
for ( int i = 0; i < 객체명.length; i++){
    객체명[i] = new 클래스명(i);

메소드 ( c의 함수와 같은 개념 ) 
- 자바의 모든 메소드는 반드시 클래스 안에 있어야 함

- 접근지정자 데이터형 메소드이름(매개변수 인자){
        메소드 코드 
  }
  
ex) public int getSum(int i, int j){
        return i + j;
    }


오버로딩 
- 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성 
- 메소드 이름이 동일해야한다. 
- 매개변수의 개수가 다르거나, 타입이 서로 달라야 한다. 
- 리턴 타입 즉 ( 메소드의 데이터형 ) 과는 관련이 없다.

객체 소멸 
- new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려주는 행위 
- 소멸된 객체 공간은 가용 메모리에 포함 

★ 자바에서는 사용자가 임의로 객체소멸을 할 수 없다. 
- 객체 소멸은 자바 가상 기계의 고유한 역할 


★ 가비지 
- 가리키는 레퍼런스가 하나도 없는 객체 
- 더 이상 접근할 수 없어 사용할 수 없게 된 메모리 

★ 가비지 컬렉션 
- 자바 가상 머신이 가비지를 자동으로 수집, 반환 
- 가비지 컬렉터에 의해 자동 수행 

패키지 개념 
- 상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리 
- 자바 응용프로그램은 하나 이상의 패키지로 구성 
- 여러 관련있는 클래스를 하나로 묶어서 관리 

접근지정자 
- private : 자신의 클래스 이외에는 접근 불가능 
- protected : 자신 또는 상속 받은 자식 클래스 이외에는 접근 불가능 
- public : 모두가 접근할 수 있음 
- 디폴트 : 같은 패키지에 있는 스크립트들은 접근 가능 

멤버변수의 초기화
- 멤버변수 : 초기화 하지않고 사용 가능 
  - 멤버변수는 초기값이 이미 지정되어있다. 
- 지역변수 : 초기화 하지않고 사용하면 에러 


★ static 멤버 
- static 멤버는 클래스당 하나만 생성 가능 
- 객체들에 의해 공유됨 
- 클래스 멤버라고 부름 
- heap영역에 올라가서 어디서든지 클래스로 접근하여 사용 가능 


static 멤버 사용
- 클래스 이름으로 접근 가능 
- 객체의 멤버로 접근 가능 
 
- 전역변수와 전역함수를 만들 때 사용 
- 공유 멤버를 만들고자 할 때 사용 


★ static 메소드의 제약 조건 
- static 메소드는 오직 static 멤버만 접근 가능 
- non-static 메소드는 static멤버 사용 가능 
- static에서 non-static은 멤버 사용 불가능 
- static 메소드는 this 사용불가 


final 클래스와 메소드 
- final 클래스 : 더 이상 클래스 상속이 불가능 
- final 메소드 : 더 이상 오버라이딩 불가능 

final 필드 
- 상수 선언 -> 상수를 선언할 때 사용한다.
- 초기 값을 무조건 기정하여야 한다. 
- 실행중에는 값을 변경할 수 없다. 
=========================================================================================================

상속 

상속의 필요성 
- 코드의 중복제거 
- 코드의 간결화 
- 계층분류로 클래스 관리가 용이 
- 재사용성과 확장성을 통한 소프트웨어 생산성 향상 

★ 상속 선언
★ extends 키워드로 선언 
- 부모 클래스 -> 슈퍼클래스, 자식클래스 -> 서브 클래스 
- 선언시 자식은 부모에 접근할 수 있지만 부모는 자식에 접근이 불가능 

자바의 상속 특징 
  - 클래스 다중 상속 불허 
  - 자바는 인터페이스의 다중 상속 허용
  
  - 모든 자바클래스는 묵시적으로 Object 클래스를 상속 받음 
  - Java.lang.Object 는 모든 클래스의 슈퍼클래스 
  

protected 멤버 
- 상속되는 서브 클래스에게 허용 

서브 클래스와 슈퍼 클래스 생성자 호출 
- 슈퍼클래스의 생성자가 먼저 실핼된 후 서브 클래스의 생성자 실행 

서브 클래스와 슈퍼 클래스의 생성자 선택 
- 서브 클래스의 생성자와 슈퍼클래스의 생성자가 결정되는 방식 
  - 개발자가 명시적으로 선택 
  - super() 키워드를 사용하여 선택 
  - 컴파일러가 기본생성자 선택 
  
  
super()로 슈퍼클래스의 생성자 명시적 선택 
- super()
  - 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출 
  - 인자를 이용하여 슈퍼클래스의 적당한 생성자 호출 
  - 반드시 서브 클래스 생성자 코드 제일 첫 라인에 와야함 



★ 업캐스팅 
  - 기본클래스의 포인터로 파생클래스의 객체를 가리키는 것을 말한다. 
  - 서브 클래스의 레퍼런스를 슈퍼클래스 레퍼런스에 대입  
  - 슈퍼클래스가 서브 클래스 객체를 가리키게 되는 현상 
 
  - 단, 부모는 자식에 접근할 수 없다. 
  - 업캐스팅한 레퍼런스로는 오직 슈퍼클래스의 멤버만 접근 
  - 업캐스팅은 상속관계에서만 발생 
 
★ 다운 캐스팅 
  - 업캐스팅된 것을 다시 원래대로 되돌리는 것  
  - 반드시 명시적 타입 변환 지정 
  - ex) s = (Student)p;


★ instanceof 연산자 
- 레퍼런스가 가리키는 객체의 타입 식별 
- 레퍼런스가 가리키는 객체가 무엇인가 판별 
사용법
- 객체레퍼런스 instanceof 클래스타입
- 연산결과 : true / false의 불린 값 

메소드 오버라이딩 
  - 서브 클래스에서 슈퍼 클래스의 메소드를 중복 작성 
  - 항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보장 
  - 슈퍼클래스 메소드의 원형과 동일하게 작성 
  
  - 오버라이딩으로 다형성 실현 
    - 하나의 인터페이스에 서로 다른 구현 
    - 슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현 
  
동적 바인딩 
  - 실행할 메소드를 컴파일 할 때 결정하지 않고 실행할 때 결정하는 것 
  - 자바는 동적바인딩을 통해서 서브 클래스에 구현되어 있는 오버라이딩 메소드가 항상 실행되도록 보장 
  
  - 이미 정해져 있는것에 접근하는 것이 아닌 실행 중에 선택하여 값이 변경되는 것 
  - 대부분 오버라이딩에서 일어나는 거 같음 
  

추상 메소드 ( abstract ) 
  - abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언 
  - 가상함수 라고 생각하면 편함 

추상 클래스
  - 추상 메소드를 가지며, abstact로 선언된 클래스 
  - 추상 메소드 없이, abstract로 선언한 클래스 
  
  
- 추상클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없다.
- 객체 생성 불가능 

추상 클래스 상속과 구현 
- 추상 클래스를 상속 받으면 추상 클래스가 됨 
- 서브 클래스도 abstract로 선언 해야함 

추상 클래스 구현 
- 서브 클래스에서 슈퍼클래스의 모든 추상 메소드를 오버라이딩하여 실행 가능한 코드로 구현하는 것 
- abstract 함수는 무조건 서브 클래스에서 구현을 해야함 

추상 클래스의 목적 
  - 다형성의 실현
  - 자식이 무조건 구현해야할 메소드를 추상으로 만들면 까먹지 않고 기능을 구현할 수 있음 

인터페이스 
- 클래스가 구현해야 할 메소드들이 선언되는 추상형 
- 

















instanceof 연산자
- 레퍼런스가 가리키는 객체의 타입 식별 
- PPT 5장 34p 중요 ( 외우기 ) 
- 자식의 레퍼런스를 다 가져오기 위해서 쓰는것 

메소드 오버라이딩 
- 서브 클래스에서 슈퍼 클래스의 메소드를 중복 작성 
- 항상 서브 클래스에 오버라이딩한 메소드가 실행 되도록 보장 
- 동적 바인딩 
- 슈퍼클래스 메소드의 원형과 동일하게 작성 

오버라이딩을 하는 이유 
- 다형성 
- 하나의 인터페이스에 서로 다른 구현 
- 슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현 

- PPT 5장 40p 중요 ( 외우기 ) 
- PPT 5장 ( 오버라이딩과 업케스팅 같이 사용하기 ) 

컴파일러가 기계어로 번역할 때 '정적바인딩' 을 한다. ( 이미 나올때 결과가 정해져 있는 (실행 이전에 이미 결과가 정해짐 ) ) 
- compil에 이미 결정이 난 것을 말한다. 

오버라이딩 중에는 동적 바인딩을 한다. ( 누구를 호출하는 것을 실행 도중에 선택 ) 
- 실행할 메소드를 컴파일 할 때(compile time)에 결정하지 않고실행 할 때(run time)에 결정하는 것

super 키워드 
- 부모의 멤버를 자식에서 접근할 때 사용되는 레퍼런스 
- super.멤버 
- 서브클래스에서만 사용가능 
- 슈퍼클래스의 필드 접근 
- 정적 바인딩 

추상클래스 
- 추상 메소드 : adstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언 
- 추상 클래스 : 추상 메소드를 가지며, adstract로 선언된 클래스 
               추상 메소드 없이, abstrac로 선언한 클래스 
               
추상 클래스를 부모가 가지고 있으면 자식은 무조건 그 메소드를 가지고 있어야 한다.

- 추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음.

추상 클래스의 상속과 구현 
- 추상 클래스를 상속 받으면 추상 클래스가 됨 
- 서브 클래스도 abstract로 선언해야 됨 
- 서브 클래스에서 슈퍼클래스의 모든 추상 메소드를 오버라이딩하여 실행하는한 코드로 구현하는 것 

추상클래스의 목적
- 상속을 위한 슈퍼 클래스로 활용하는 것 
- 다형성의 실현 

추상클래스는 객체를 생성할 수 없지만 
레퍼런스 값을 생성할 수 있다.











